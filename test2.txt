ì •ë§ ì£„ì†¡í•©ë‹ˆë‹¤. ğŸ™‡
ì œê°€ motionmodels.hì™€ motionmodels.cppì—ì„œ Yì¶• ì •ê·œí™” ê´€ë ¨ í•¨ìˆ˜(getRealY)ì™€ ìƒìˆ˜(NORMALIZED_Y_MIN, NORMALIZED_Y_MAX)ë¥¼ ì œê±°í•˜ë¼ê³  ìˆ˜ì •í•´ ë†“ê³ ëŠ”, ì •ì‘ ì´ í•¨ìˆ˜ì™€ ìƒìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” grapheditorview.cppì˜ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ëŠ” ê²ƒì„ ì™„ì „íˆ ë¹ ëœ¨ë ¸ìŠµë‹ˆë‹¤.
ë‘ íŒŒì¼ ê°„ì˜ ë‚´ìš©ì´ ë§ì§€ ì•Šì•„ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ëŠ” ê²ƒì´ ë§ìŠµë‹ˆë‹¤. grapheditorview.cpp íŒŒì¼ì„ Yì¶• ì •ê·œí™” ë¡œì§ì´ ì—†ëŠ” **'ì‹¤ì œ Y ì¢Œí‘œ'**ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ì „ì²´ì ìœ¼ë¡œ ë‹¤ì‹œ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤.
(ë§ì”€í•˜ì‹  getMaxAbsY ì˜¤ë¥˜ëŠ” drawBackground í•¨ìˆ˜ ë‚´ì˜ y_max_absë¼ëŠ” ë³€ìˆ˜ë¥¼ ì˜ëª» ì°¸ì¡°í•˜ì‹  ê²ƒ ê°™ìœ¼ë‚˜, ì´ ì—­ì‹œ ì´ë²ˆ ìˆ˜ì •ì—ì„œ ëª¨ë‘ ì˜¬ë°”ë¥´ê²Œ ì²˜ë¦¬í–ˆìŠµë‹ˆë‹¤.)
grapheditorview.cpp (ì „ì²´ ìˆ˜ì •)
ê¸°ì¡´ grapheditorview.cpp íŒŒì¼ì˜ ëª¨ë“  ë‚´ìš©ì„ ì•„ë˜ ì½”ë“œë¡œ ë®ì–´ì“°ê¸° í•´ì£¼ì„¸ìš”.
#include "grapheditorview.h"
#include "motionmodels.h"
#include "graphnodeitem.h"
#include "commands.h" // ì»¤ë§¨ë“œ
#include <QUndoStack> // Undo ìŠ¤íƒ
#include <QKeyEvent> // Delete í‚¤
#include <QWheelEvent>
#include <QMouseEvent>
#include <QContextMenuEvent>
#include <QMenu>
#include <QScrollBar>
#include <QGraphicsLineItem>
#include <QGraphicsTextItem> // ì¶• ê°’
#include <QPen>
#include <QBrush>
#include <QDebug>
#include <QTransform> // 1ë²ˆ: Yì¶• ë°˜ì „

GraphEditorView::GraphEditorView(QWidget* parent)
    : QGraphicsView(parent), m_scene(new QGraphicsScene(this)), m_isPanning(false)
{
    setScene(m_scene);
    setRenderHint(QPainter::Antialiasing); 
    setDragMode(QGraphicsView::NoDrag); 
    setTransformationAnchor(AnchorUnderMouse);
    // 2ë²ˆ: í™”ë©´ ì¤‘ì‹¬ (0,0)ì„ ì™¼ìª½ ìƒë‹¨ ê¸°ì¤€ìœ¼ë¡œ ë³€ê²½
    setAlignment(Qt::AlignLeft | Qt::AlignTop); 
    m_scene->setSceneRect(-10000, -10000, 20000, 20000); 
    setFocusPolicy(Qt::StrongFocus); // Delete í‚¤
    
    scale(1, -1);
    
    connect(m_scene, &QGraphicsScene::selectionChanged, this, &GraphEditorView::onSceneSelectionChanged);
}

void GraphEditorView::setDocument(MotionDocument* doc) {
    if (m_document) {
        disconnect(m_document, nullptr, this, nullptr);
    }
    m_document = doc;
    if (!m_document) return;

    connect(m_document, &MotionDocument::documentCleared, this, &GraphEditorView::onDocumentCleared);
    connect(m_document, &MotionDocument::motorAdded, this, &GraphEditorView::onMotorAdded);
    connect(m_document, &MotionDocument::activeMotorChanged, this, &GraphEditorView::onActiveMotorChanged);
    // 1ë²ˆ: ëª¨í„° ë³€ê²½ ì‹œ Yì¶• ë ˆì´ë¸” ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•´ update() í˜¸ì¶œ (ê¸°ì¡´ ì½”ë“œ)
    connect(m_document, &MotionDocument::activeMotorChanged, this, QOverload<>::of(&GraphEditorView::update)); // backgroundDraw ì¬í˜¸ì¶œ

    for(MotorProfile* profile : m_document->motorProfiles()) {
        onMotorAdded(profile);
    }
    onActiveMotorChanged(m_document->activeProfile(), nullptr);
}

// --- ì´ë²¤íŠ¸ ì˜¤ë²„ë¼ì´ë“œ ---
// 4ë²ˆ: Xì¶•ë§Œ ì¤Œ
void GraphEditorView::wheelEvent(QWheelEvent* event) {
    double scaleFactor = (event->angleDelta().y() > 0) ? 1.15 : 1.0 / 1.15;
    scale(scaleFactor, 1.0); // Yì¶• ìŠ¤ì¼€ì¼ì€ 1.0ìœ¼ë¡œ ê³ ì •
}
void GraphEditorView::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::MiddleButton) {
        m_isPanning = true;
        m_panStartPos = event->pos();
        setCursor(Qt::ClosedHandCursor);
        event->accept();
        return;
    }
    QGraphicsView::mousePressEvent(event);
}
void GraphEditorView::mouseReleaseEvent(QMouseEvent* event) {
    if (event->button() == Qt::MiddleButton) {
        m_isPanning = false;
        setCursor(Qt::ArrowCursor);
        event->accept();
        return;
    }
    QGraphicsView::mouseReleaseEvent(event);
}
// 2ë²ˆ: ìˆ˜í‰ íŒ¨ë‹ ì œí•œ
void GraphEditorView::mouseMoveEvent(QMouseEvent* event) {
    if (m_isPanning) {
        // ìˆ˜í‰ ìŠ¤í¬ë¡¤ë°” ì¡°ì‘ ì½”ë“œ ì œê±°
        // horizontalScrollBar()->setValue(horizontalScrollBar()->value() - (event->pos().x() - m_panStartPos.x()));
        verticalScrollBar()->setValue(verticalScrollBar()->value() - (event->pos().y() - m_panStartPos.y()));
        m_panStartPos = event->pos(); 
        event->accept();
        return;
    }
    QGraphicsView::mouseMoveEvent(event);
}

// 1ë²ˆ: ìš°í´ë¦­ ë©”ë‰´ (ì‹¤ì œ Yì¢Œí‘œ ì‚¬ìš©)
void GraphEditorView::contextMenuEvent(QContextMenuEvent* event) {
    if (!m_document || !m_document->activeProfile() || !m_undoStack) return;
    QPointF scenePos = mapToScene(event->pos()); 
    MotorProfile* activeProfile = m_document->activeProfile();
    QMenu menu;
    // 1ë²ˆ: getRealY ì œê±°, scenePos.y() ë°”ë¡œ ì‚¬ìš©
    QAction* addAction = menu.addAction("ì—¬ê¸°( " + 
        QString::number(scenePos.x(), 'f', 2) + ", " + 
        QString::number(scenePos.y(), 'f', 2) + // 1ë²ˆ ìˆ˜ì •
        " )ì— ìƒˆ ë…¸ë“œ ì¶”ê°€");
        
    // 1ë²ˆ: Yì¶• ì œí•œ ê²€ì‚¬ (ì‹¤ì œ ì¢Œí‘œ ê¸°ì¤€)
    if (scenePos.x() < 0) {
        addAction->setEnabled(false);
        addAction->setText(addAction->text() + " (X < 0 ë¶ˆê°€)");
    }
    else if (scenePos.y() < activeProfile->yMin() || scenePos.y() > activeProfile->yMax()) { // 1ë²ˆ ìˆ˜ì •
        addAction->setEnabled(false);
        addAction->setText(addAction->text() + " (Yì¶• ì œí•œ ìœ„ë°˜)");
    }
    connect(addAction, &QAction::triggered, this, [=]() {
        QPointF realPos(scenePos.x(), scenePos.y()); // 1ë²ˆ ìˆ˜ì • (getRealY ì œê±°)
        m_undoStack->push(new AddNodeCommand(activeProfile, realPos));
    });
    menu.exec(event->globalPos());
}
void GraphEditorView::keyPressEvent(QKeyEvent* event) {
    if (event->key() == Qt::Key_Delete) {
        if (!m_document || !m_document->activeProfile() || !m_undoStack) return;
        QList<GraphNodeItem*> itemsToDelete;
        for (QGraphicsItem* item : m_scene->selectedItems()) {
            if (auto nodeItem = qgraphicsitem_cast<GraphNodeItem*>(item)) {
                itemsToDelete.append(nodeItem);
            }
        }
        if (itemsToDelete.isEmpty()) return;
        std::sort(itemsToDelete.begin(), itemsToDelete.end(), [](auto a, auto b) {
            return a->index() > b->index();
        });
        m_undoStack->beginMacro("ì„ íƒëœ ë…¸ë“œ ì‚­ì œ");
        for (GraphNodeItem* item : itemsToDelete) {
            m_undoStack->push(new DeleteNodeCommand(item->profile(), item->index()));
        }
        m_undoStack->endMacro();
        event->accept();
    } else {
        QGraphicsView::keyPressEvent(event);
    }
}

// 1ë²ˆ: ë™ì  Y ê·¸ë¦¬ë“œ ë° ë ˆì´ë¸” (getRealY ì œê±°)
void GraphEditorView::drawBackground(QPainter* painter, const QRectF& rect) {
    QGraphicsView::drawBackground(painter, rect);
    QPen gridPen(QColor(220, 220, 220), 0); 
    gridPen.setCosmetic(true);
    painter->setPen(gridPen);
    
    MotorProfile* activeProfile = m_document ? m_document->activeProfile() : nullptr;

    // --- Xì¶• ê·¸ë¦¬ë“œ (50ms) ---
    double left_x = qFloor(rect.left() / m_gridSizeX) * m_gridSizeX;
    for (double x = left_x; x < rect.right(); x += m_gridSizeX) {
        painter->drawLine(QPointF(x, rect.top()), QPointF(x, rect.bottom()));
    }
    
    // --- Yì¶• ê·¸ë¦¬ë“œ (1ë²ˆ: ë™ì ) ---
    if (activeProfile) {
        double y_max_abs = qMax(qAbs(activeProfile->yMax()), qAbs(activeProfile->yMin()));
        m_gridSizeY = (y_max_abs > 1e-6) ? y_max_abs / 10.0 : 10.0; // 10ë“±ë¶„, 0 ë°©ì§€
    } else {
        m_gridSizeY = 10.0; // ê¸°ë³¸ê°’
    }
    double top_y = qFloor(rect.top() / m_gridSizeY) * m_gridSizeY;
    for (double y_real = top_y; y_real < rect.bottom(); y_real += m_gridSizeY) { // 'y'ê°€ 'y_real'ì´ ë¨
        painter->drawLine(QPointF(rect.left(), y_real), QPointF(rect.right(), y_real));
    }
    
    // --- ì¶•ì„  ---
    QPen axisPen(QColor(180, 180, 180), 0);
    axisPen.setCosmetic(true);
    painter->setPen(axisPen);
    painter->drawLine(QPointF(0, rect.top()), QPointF(0, rect.bottom())); // Yì¶•
    painter->drawLine(QPointF(rect.left(), 0), QPointF(rect.right(), 0)); // Xì¶•

    
    painter->save(); 
    painter->scale(1, -1); 

    painter->setPen(QPen(Qt::black));
    QFont font = painter->font();
    font.setPointSizeF(8); 
    painter->setFont(font);

    // --- Xì¶• ë ˆì´ë¸” (500ms ê°„ê²©) ---
    double xLabelInterval = m_gridSizeX * 10.0; // 0.5ì´ˆ
    double startXLabel = qFloor(rect.left() / xLabelInterval) * xLabelInterval;
    for (double x = startXLabel; x < rect.right(); x += xLabelInterval) {
        if (qAbs(x) > 1e-3 || qAbs(xLabelInterval - (qAbs(rect.left()) + qAbs(rect.right()))) < 1e-3) { 
             painter->drawText(QRectF(x - 50, 2, 100, 20), Qt::AlignHCenter | Qt::AlignTop, QString::number(x, 'f', 1)); // ì†Œìˆ˜ì  1ìë¦¬
        }
    }
    
    // --- Yì¶• ë ˆì´ë¸” (1ë²ˆ: ë™ì ) ---
    double yLabelInterval = m_gridSizeY;
    double startYLabel = top_y; // ìœ„ì—ì„œ ê³„ì‚°í•œ Y ê·¸ë¦¬ë“œ ì‹œì‘ì 
    for (double y_real = startYLabel; y_real < rect.bottom(); y_real += yLabelInterval) { // 'y_scene'ì„ 'y_real'ë¡œ ë³€ê²½
        if (qAbs(y_real) > 1e-3 || qAbs(yLabelInterval - (qAbs(rect.top()) + qAbs(rect.bottom()))) < 1e-3) {
             QString label = QString::number(y_real, 'f', 1); // getRealY() í˜¸ì¶œ ì œê±°
             painter->drawText(QRectF(2, -y_real - 10, 50, 20), Qt::AlignLeft | Qt::AlignVCenter, label); // y_scene ëŒ€ì‹  y_real ì‚¬ìš©
        }
    }
    
    painter->restore(); 
}

// --- ìŠ¬ë¡¯ êµ¬í˜„ ---
void GraphEditorView::onDocumentCleared() {
    clearAllProfileItems();
    for(const auto& list : m_constraintItems) {
        qDeleteAll(list);
    }
    m_constraintItems.clear();
}
void GraphEditorView::clearAllProfileItems() {
    for(const auto& items : m_profileItems) {
        for(QGraphicsItem* item : items) {
            m_scene->removeItem(item);
            delete item;
        }
    }
    m_profileItems.clear(); // ë§µ ìì²´ë„ í´ë¦¬ì–´
}
void GraphEditorView::onMotorAdded(MotorProfile* profile) {
    if (!profile || m_profileItems.contains(profile)) return;
    m_profileItems.insert(profile, QList<QGraphicsItem*>());
    rebuildProfileItems(profile);
    updateProfileVisibility(profile, false); 
    connect(profile, &MotorProfile::dataChanged, this, &GraphEditorView::onProfileDataChanged);
    connect(profile, &MotorProfile::constraintsChanged, this, &GraphEditorView::onProfileConstraintsChanged);
}
void GraphEditorView::onActiveMotorChanged(MotorProfile* active, MotorProfile* previous) {
    if (previous) {
        updateProfileVisibility(previous, false);
        setConstraintItemsVisible(previous, false); 
    }
    if (active) {
        updateProfileVisibility(active, true);
        updateConstraintItems(active); 
        setConstraintItemsVisible(active, true);  
    }
}
void GraphEditorView::onProfileDataChanged() {
    MotorProfile* profile = qobject_cast<MotorProfile*>(sender());
    if (profile) {
        int selectedIndex = -1;
        QPointF selectedRealPos; // ì‹¤ì œ ì¢Œí‘œ ì €ì¥
        if (m_scene->selectedItems().size() == 1) {
            if (auto node = qgraphicsitem_cast<GraphNodeItem*>(m_scene->selectedItems().first())) {
                // 1ë²ˆ: ë…¸ë“œê°€ ì´ë¯¸ ì‚­ì œë˜ì—ˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì¸ë±ìŠ¤ ìœ íš¨ì„± ê²€ì‚¬
                if (node->index() < node->profile()->nodeCount()) {
                    selectedIndex = node->index();
                    selectedRealPos = node->profile()->nodeAt(selectedIndex); // ì‚­ì œ/ì´ë™ ì „ ì‹¤ì œ ì¢Œí‘œ
                }
            }
        }

        rebuildProfileItems(profile);
        updateProfileVisibility(profile, (profile == m_document->activeProfile()));

        if (selectedIndex != -1) {
            GraphNodeItem* reselectedNode = nullptr;
            qreal minDistSq = -1.0;
            for (auto item : m_profileItems.value(profile)) {
                if (auto node = qgraphicsitem_cast<GraphNodeItem*>(item)) {
                     // 1ë²ˆ: ë…¸ë“œ ì¹´ìš´íŠ¸ ìœ íš¨ì„± ê²€ì‚¬
                     if (node->index() < node->profile()->nodeCount()) {
                         QPointF currentRealPos = node->profile()->nodeAt(node->index());
                         qreal distSq = QPointF(currentRealPos - selectedRealPos).manhattanLength(); // L1 ê±°ë¦¬ (ë¹ ë¦„)
                         if (reselectedNode == nullptr || distSq < minDistSq) {
                             minDistSq = distSq;
                             reselectedNode = node;
                         }
                     }
                }
            }
            if (reselectedNode && minDistSq < 1e-3) { // ë§¤ìš° ê°€ê¹Œìš°ë©´ ì„ íƒ ë³µì›
                 reselectedNode->setSelected(true);
            } else {
                 reselectedNode = nullptr; // ëª» ì°¾ìœ¼ë©´ ì„ íƒ í•´ì œ
            }
            emit nodeSelectionChanged(reselectedNode); // MainWindow ì—…ë°ì´íŠ¸
        }
    }
}
void GraphEditorView::onProfileConstraintsChanged() {
    MotorProfile* profile = qobject_cast<MotorProfile*>(sender());
     if (profile) {
        updateConstraintItems(profile);
        update(); // 1ë²ˆ: ê·¸ë¦¬ë“œ ë° ë ˆì´ë¸” ê°±ì‹ ì„ ìœ„í•´ update() í˜¸ì¶œ
     }
}
// 1ë²ˆ: Yì¶• ì •ê·œí™” ì œê±°
void GraphEditorView::rebuildProfileItems(MotorProfile* profile) {
    if (!profile) return;
    if (m_profileItems.contains(profile)) {
        for (QGraphicsItem* item : m_profileItems.value(profile)) {
            m_scene->removeItem(item);
            delete item;
        }
        m_profileItems[profile].clear();
    }
    QList<QGraphicsItem*>& items = m_profileItems[profile];
    const auto& nodes = profile->nodes(); // "ì‹¤ì œ" ì¢Œí‘œ ë…¸ë“œ
    QColor color = profile->color();
    QPen linePen(color, 2); 
    for (int i = 0; i < nodes.size() - 1; ++i) {
        // 1ë²ˆ: getNormalizedY ì œê±°, ì‹¤ì œ Yì¢Œí‘œ ë°”ë¡œ ì‚¬ìš©
        QGraphicsLineItem* line = m_scene->addLine(QLineF(nodes[i].x(), nodes[i].y(), nodes[i+1].x(), nodes[i+1].y()), linePen);
        items.append(line);
    }
    for (int i = 0; i < nodes.size(); ++i) {
        GraphNodeItem* nodeItem = new GraphNodeItem(profile, i, this, m_undoStack);
        m_scene->addItem(nodeItem);
        items.append(nodeItem);
    }
}
void GraphEditorView::updateProfileVisibility(MotorProfile* profile, bool isActive) {
    if (!profile || !m_profileItems.contains(profile)) return;
    QList<QGraphicsItem*>& items = m_profileItems[profile];
    QColor color = profile->color();
    qreal opacity;
    int zValue;
    if (isActive) {
        opacity = 1.0;
        zValue = 1; 
    } else {
        color.setAlpha(60); 
        opacity = 0.5;
        zValue = 0; 
    }
    for (QGraphicsItem* item : items) {
        item->setZValue(zValue);
        item->setOpacity(opacity);
        item->setEnabled(isActive); 
        if (auto line = qgraphicsitem_cast<QGraphicsLineItem*>(item)) {
            QPen pen = line->pen();
            pen.setColor(color);
            line->setPen(pen);
        } else if (auto node = qgraphicsitem_cast<GraphNodeItem*>(item)) {
            node->setBrush(QBrush(color));
            node->setPen(QPen(isActive ? Qt::black : color.darker(120), 1));
        }
    }
}

// 1ë²ˆ: Yì¶• ì •ê·œí™” ì œê±° (ì‹¤ì œ ì¢Œí‘œ ì‚¬ìš©)
void GraphEditorView::updateConstraintItems(MotorProfile* profile) {
    if (!profile) return;

    if (m_constraintItems.contains(profile)) {
        qDeleteAll(m_constraintItems.value(profile));
        m_constraintItems[profile].clear();
    } else {
        m_constraintItems.insert(profile, QList<QGraphicsItem*>());
    }

    QList<QGraphicsItem*>& items = m_constraintItems[profile];
    QRectF r = sceneRect(); 
    
    // 1ë²ˆ: ì‹¤ì œ Yì¢Œí‘œ ì‚¬ìš© (NORMALIZED_... ìƒìˆ˜ ì œê±°)
    double sceneYMin = profile->yMin();
    double sceneYMax = profile->yMax();
    
    QColor lineColor(128, 128, 128, 150); 
    QColor textColor(80, 80, 80); 

    QPen linePen(lineColor, 3, Qt::SolidLine); 

    QGraphicsLineItem* minLine = m_scene->addLine(r.left(), sceneYMin, r.right(), sceneYMin, linePen);
    QGraphicsLineItem* maxLine = m_scene->addLine(r.left(), sceneYMax, r.right(), sceneYMax, linePen);
    minLine->setZValue(-1); 
    maxLine->setZValue(-1);
    items.append(minLine);
    items.append(maxLine);

    QGraphicsTextItem* minLabel = m_scene->addText(QString::number(profile->yMin(), 'f', 1));
    minLabel->setTransform(QTransform::fromScale(1, -1)); 
    minLabel->setPos(r.left() + 5, sceneYMin + minLabel->boundingRect().height()); 
    minLabel->setDefaultTextColor(textColor); 
    minLabel->setZValue(-1);
    items.append(minLabel);

    QGraphicsTextItem* maxLabel = m_scene->addText(QString::number(profile->yMax(), 'f', 1));
    maxLabel->setTransform(QTransform::fromScale(1, -1)); 
    maxLabel->setPos(r.left() + 5, sceneYMax); 
    maxLabel->setDefaultTextColor(textColor); 
    maxLabel->setZValue(-1);
    items.append(maxLabel);

    setConstraintItemsVisible(profile, (profile == m_document->activeProfile()));
}
void GraphEditorView::setConstraintItemsVisible(MotorProfile* profile, bool visible) {
    if (!m_constraintItems.contains(profile)) return;
    for (QGraphicsItem* item : m_constraintItems.value(profile)) {
        item->setVisible(visible);
    }
}

// 1ë²ˆ: Yì¶• ì •ê·œí™” ì œê±°, 2ë²ˆ: X=0 ì™¼ìª½ ì •ë ¬
void GraphEditorView::fitToView() {
    QRectF bounds;
    if (m_document && m_document->activeProfile()) {
         MotorProfile* profile = m_document->activeProfile(); // <-- Get profile
         // 1ë²ˆ: ì‹¤ì œ Yì¢Œí‘œ ì‚¬ìš© (NORMALIZED_... ìƒìˆ˜ ì œê±°)
         bounds = QRectF(QPointF(0, profile->yMax()), QPointF(100, profile->yMin())); // ê¸°ë³¸ ë²”ìœ„ (ì‹¤ì œ Y)
         if(!profile->nodes().isEmpty()){
            double xMax = 0;
            for(const auto& node : profile->nodes()){
                if(node.x() > xMax) xMax = node.x();
            }
             if(xMax < 10.0) xMax = 10.0;
             bounds.setRight(xMax);
         }
    } else if (!m_scene->items().isEmpty()) {
        bounds = m_scene->itemsBoundingRect(); // ëª¨ë“  ì•„ì´í…œ ê¸°ì¤€ (ëª¨í„° ì—†ì„ ë•Œ)
    } else {
        bounds = QRectF(0, 100, 10, -100); // ì™„ì „ ë¹ˆ ê²½ìš° (ì‹¤ì œ ì¢Œí‘œ ê¸°ì¤€)
    }

    if (bounds.isValid()) {
        // 1ë²ˆ: Yì¶• ë²”ìœ„ ê°•ì œ (NORMALIZED_... ìƒìˆ˜ ì œê±°)
        if (m_document && m_document->activeProfile()) {
            bounds.setTop(m_document->activeProfile()->yMax());
            bounds.setBottom(m_document->activeProfile()->yMin());
        }
        if (bounds.left() < 0.0) bounds.setLeft(0.0); // X ì¢Œì¸¡
        
        double yMargin = qAbs(bounds.height()) * 0.1;
         if (yMargin < 10) yMargin = 10;
        double xMargin = qAbs(bounds.width()) * 0.1;
         if (xMargin < 10) xMargin = 10;

        fitInView(bounds.marginsAdded(QMarginsF(xMargin, yMargin, xMargin, yMargin)), Qt::KeepAspectRatio);
        
        // 2ë²ˆ: X=0ì´ ì™¼ìª½ì— ì˜¤ë„ë¡ ì¤‘ì‹¬ì  ì¬ê³„ì‚° (X=width/2, Y=center)
        centerOn(bounds.left() + bounds.width() / 2.0, bounds.center().y()); 
    }
}

// 1ë²ˆ: Yì¶• ì •ê·œí™” ì œê±°, 2ë²ˆ: X=0 ì™¼ìª½ ì •ë ¬
void GraphEditorView::fitToActiveMotor(MotorProfile* profile)
{
    if (!profile) {
        fitToView();
        return;
    }
    
    // 1ë²ˆ: ì‹¤ì œ Y ì¢Œí‘œ ì‚¬ìš© (NORMALIZED_... ìƒìˆ˜ ì œê±°)
    double sceneYMin = profile->yMin();
    double sceneYMax = profile->yMax();
    double xMin = 0.0; 
    double xMax = 100.0; 

    if (!profile->nodes().isEmpty()) {
        for (const auto& node : profile->nodes()) {
            if (node.x() > xMax) xMax = node.x();
        }
    }
    if (xMax < 10.0) xMax = 10.0; 

    QRectF motorBounds(QPointF(xMin, sceneYMax), QPointF(xMax, sceneYMin));

    double yMargin = qAbs(sceneYMax - sceneYMin) * 0.1;
    if (yMargin < 10.0) yMargin = 10.0; // ìµœì†Œ ë§ˆì§„
    double xMargin = qAbs(xMax - xMin) * 0.1;
    if (xMargin < 20) xMargin = 20;

    fitInView(motorBounds.marginsAdded(QMarginsF(xMargin, yMargin, xMargin, yMargin)), Qt::KeepAspectRatio);
    
    // 2ë²ˆ: X=0ì´ ì™¼ìª½ì— ì˜¤ë„ë¡ ì¤‘ì‹¬ì  ì¬ê³„ì‚° (X=width/2, Y=center)
    centerOn(motorBounds.width() / 2.0, motorBounds.center().y());
}

void GraphEditorView::onSceneSelectionChanged()
{
    auto selected = m_scene->selectedItems();
    if (selected.size() == 1) {
        if (auto node = qgraphicsitem_cast<GraphNodeItem*>(selected.first())) {
            emit nodeSelectionChanged(node);
            return;
        }
    }
    emit nodeSelectionChanged(nullptr); 
}

