네, 알겠습니다. X축의 단위를 '초(seconds)' (예: 0.05)에서 '밀리초(milliseconds)' (예: 50)로 변경하시는군요.
이 작업을 위해서는 3개 파일(grapheditorview.h, grapheditorview.cpp, mainwindow.cpp)의 수정이 필요합니다.
"Y축 조절" 요청은 X축의 스케일이 1000배 변경됨에 따라 기존의 뷰 설정(기본 줌, 예제 데이터)이 맞지 않아 발생하는 문제로 보입니다. X축 단위를 변경하면서 이 부분도 함께 수정하겠습니다.
1. grapheditorview.h (수정)
X축 그리드 기본 단위를 50.0으로 변경합니다.
// ... (파일 상단부) ...
class GraphEditorView : public QGraphicsView {
    // ... (Q_OBJECT, public, signals, protected) ...

private:
    // ... (private functions) ...
    
    QMap<MotorProfile*, QList<QGraphicsItem*>> m_constraintItems; 
    void setConstraintItemsVisible(MotorProfile* profile, bool visible);

    QUndoStack* m_undoStack = nullptr; 
    
    bool m_snapToGrid = false;
    // 3번: X, Y 그리드 크기 분리
    double m_gridSizeX = 50.0; // 1번: 0.05 -> 50 (50ms)
    double m_gridSizeY = 10.0; // '실제' Y값 간격 (동적으로 변경됨)
    
    QGraphicsScene* m_scene;
// ... (파일 하단부) ...

2. grapheditorview.cpp (수정)
drawBackground, fitToView, fitToActiveMotor 함수를 수정해야 합니다.
 * drawBackground: X축 레이블 간격을 m_gridSizeX (50)로 변경하고, 소수점을 제거합니다.
 * fitTo...: X축 기본 줌 레벨을 100, 10에서 10000, 1000 등으로 변경합니다.
<!-- end list -->
// ... (파일 상단부) ...
#include <QDebug>
#include <QTransform> // 1번: Y축 반전

// (다른 함수들은 그대로 둡니다) ...

// 1번: X축 레이블 간격 및 포맷 수정
void GraphEditorView::drawBackground(QPainter* painter, const QRectF& rect) {
    QGraphicsView::drawBackground(painter, rect);
    QPen gridPen(QColor(220, 220, 220), 0); 
    gridPen.setCosmetic(true);
    painter->setPen(gridPen);
    
    MotorProfile* activeProfile = m_document ? m_document->activeProfile() : nullptr;

    // --- X축 그리드 (50ms) ---
    double left_x = qFloor(rect.left() / m_gridSizeX) * m_gridSizeX;
    for (double x = left_x; x < rect.right(); x += m_gridSizeX) {
        painter->drawLine(QPointF(x, rect.top()), QPointF(x, rect.bottom()));
    }
    
    // --- Y축 그리드 (1번: 동적) ---
    if (activeProfile) {
        double y_max_abs = qMax(qAbs(activeProfile->yMax()), qAbs(activeProfile->yMin()));
        m_gridSizeY = (y_max_abs > 1e-6) ? y_max_abs / 10.0 : 10.0; // 10등분, 0 방지
    } else {
        m_gridSizeY = 10.0; // 기본값
    }
    double top_y = qFloor(rect.top() / m_gridSizeY) * m_gridSizeY;
    for (double y_real = top_y; y_real < rect.bottom(); y_real += m_gridSizeY) { // 'y'가 'y_real'이 됨
        painter->drawLine(QPointF(rect.left(), y_real), QPointF(rect.right(), y_real));
    }
    
    // --- 축선 ---
    QPen axisPen(QColor(180, 180, 180), 0);
    axisPen.setCosmetic(true);
    painter->setPen(axisPen);
    painter->drawLine(QPointF(0, rect.top()), QPointF(0, rect.bottom())); // Y축
    painter->drawLine(QPointF(rect.left(), 0), QPointF(rect.right(), 0)); // X축

    
    painter->save(); 
    painter->scale(1, -1); 

    painter->setPen(QPen(Qt::black));
    QFont font = painter->font();
    font.setPointSizeF(8); 
    painter->setFont(font);

    // --- X축 레이블 (1번: 50ms 간격, 정수) ---
    double xLabelInterval = m_gridSizeX; // 1번: 50.0 (m_gridSizeX * 10.0 -> m_gridSizeX)
    double startXLabel = qFloor(rect.left() / xLabelInterval) * xLabelInterval;
    for (double x = startXLabel; x < rect.right(); x += xLabelInterval) {
        if (qAbs(x) > 1e-3 || qAbs(xLabelInterval - (qAbs(rect.left()) + qAbs(rect.right()))) < 1e-3) { 
             painter->drawText(QRectF(x - 50, 2, 100, 20), Qt::AlignHCenter | Qt::AlignTop, QString::number(x, 'f', 0)); // 1번: 'f', 1 -> 'f', 0
        }
    }
    
    // --- Y축 레이블 (1번: 동적) ---
    double yLabelInterval = m_gridSizeY;
    double startYLabel = top_y; // 위에서 계산한 Y 그리드 시작점
    for (double y_real = startYLabel; y_real < rect.bottom(); y_real += yLabelInterval) { // 'y_scene'을 'y_real'로 변경
        if (qAbs(y_real) > 1e-3 || qAbs(yLabelInterval - (qAbs(rect.top()) + qAbs(rect.bottom()))) < 1e-3) {
             QString label = QString::number(y_real, 'f', 1); // getRealY() 호출 제거
             painter->drawText(QRectF(2, -y_real - 10, 50, 20), Qt::AlignLeft | Qt::AlignVCenter, label); // y_scene 대신 y_real 사용
        }
    }
    
    painter->restore(); 
}

// ... (onDocumentCleared ~ setConstraintItemsVisible 함수는 그대로 둡니다) ...

// 1번: X축 스케일 변경 (100 -> 10000, 10 -> 1000)
void GraphEditorView::fitToView() {
    QRectF bounds;
    if (m_document && m_document->activeProfile()) {
         MotorProfile* profile = m_document->activeProfile(); // <-- Get profile
         // 1번: 실제 Y좌표 사용 (NORMALIZED... 상수 제거)
         bounds = QRectF(QPointF(0, profile->yMax()), QPointF(10000, profile->yMin())); // 1번: 100 -> 10000
         if(!profile->nodes().isEmpty()){
            double xMax = 0;
            for(const auto& node : profile->nodes()){
                if(node.x() > xMax) xMax = node.x();
            }
             if(xMax < 1000.0) xMax = 1000.0; // 1번: 10.0 -> 1000.0
             bounds.setRight(xMax);
         }
    } else if (!m_scene->items().isEmpty()) {
        bounds = m_scene->itemsBoundingRect(); // 모든 아이템 기준 (모터 없을 때)
    } else {
        bounds = QRectF(0, 100, 10000, -100); // 1번: 10 -> 10000 (실제 좌표 기준)
    }

    if (bounds.isValid()) {
        // 1번: Y축 범위 강제 (NORMALIZED... 상수 제거)
        if (m_document && m_document->activeProfile()) {
            bounds.setTop(m_document->activeProfile()->yMax());
            bounds.setBottom(m_document->activeProfile()->yMin());
        }
        if (bounds.left() < 0.0) bounds.setLeft(0.0); // X 좌측
        
        double yMargin = qAbs(bounds.height()) * 0.1;
         if (yMargin < 10) yMargin = 10;
        double xMargin = qAbs(bounds.width()) * 0.1;
         if (xMargin < 10) xMargin = 10;

        fitInView(bounds.marginsAdded(QMarginsF(xMargin, yMargin, xMargin, yMargin)), Qt::KeepAspectRatio);
        
        // 2번: X=0이 왼쪽에 오도록 중심점 재계산 (X=width/2, Y=center)
        centerOn(bounds.left() + bounds.width() / 2.0, bounds.center().y()); 
    }
}

// 1번: X축 스케일 변경 (100 -> 10000, 10 -> 1000)
void GraphEditorView::fitToActiveMotor(MotorProfile* profile)
{
    if (!profile) {
        fitToView();
        return;
    }
    
    // 1번: 실제 Y 좌표 사용 (NORMALIZED... 상수 제거)
    double sceneYMin = profile->yMin();
    double sceneYMax = profile->yMax();
    double xMin = 0.0; 
    double xMax = 10000.0; // 1번: 100.0 -> 10000.0

    if (!profile->nodes().isEmpty()) {
        for (const auto& node : profile->nodes()) {
            if (node.x() > xMax) xMax = node.x();
        }
    }
    if (xMax < 1000.0) xMax = 1000.0; // 1번: 10.0 -> 1000.0

    QRectF motorBounds(QPointF(xMin, sceneYMax), QPointF(xMax, sceneYMin));

    double yMargin = qAbs(sceneYMax - sceneYMin) * 0.1;
    if (yMargin < 10.0) yMargin = 10.0; // 최소 마진
    double xMargin = qAbs(xMax - xMin) * 0.1;
    if (xMargin < 20) xMargin = 20;

    fitInView(motorBounds.marginsAdded(QMarginsF(xMargin, yMargin, xMargin, yMargin)), Qt::KeepAspectRatio);
    
    // 2번: X=0이 왼쪽에 오도록 중심점 재계산 (X=width/2, Y=center)
    centerOn(motorBounds.width() / 2.0, motorBounds.center().y());
}

// ... (파일 하단부) ...

3. mainwindow.cpp (수정)
생성자의 예제 데이터와 onExportDocument의 기본값을 '밀리초' 단위로 변경합니다. (X축 값 * 1000)
// ... (파일 상단부) ...
#include <QLabel> // <-- 이 줄을 추가하세요

MainWindow::MainWindow(QWidget* parent)
    : QMainWindow(parent)
{
    m_undoStack = new QUndoStack(this);
    m_document = new MotionDocument(this);
    m_view = new GraphEditorView(this);
    m_view->setDocument(m_document);
    m_view->setUndoStack(m_undoStack); 
    setCentralWidget(m_view); 

    createActions();
    createMenus();
    createDocks(); 
    
    connect(m_motorTreeWidget, &QTreeWidget::currentItemChanged, 
            this, &MainWindow::onMotorSelectionChanged);
    connect(m_document, &MotionDocument::modelChanged, 
            this, &MainWindow::onDocumentModelChanged);
    connect(m_document, &MotionDocument::activeMotorChanged, 
            this, &MainWindow::onActiveMotorSwitched);
    connect(m_fitToViewAction, &QAction::triggered, m_view, &GraphEditorView::fitToView);
    connect(m_snapGridAction, &QAction::toggled, m_view, &GraphEditorView::toggleSnapToGrid);
    
    // 1번: 뷰에서 노드 선택 시그널 연결
    connect(m_view, &GraphEditorView::nodeSelectionChanged, this, &MainWindow::onNodeSelected);
            
    qsrand(QTime::currentTime().msec()); 
    MotorProfile* m1 = m_document->addMotor("Motor 1 (Red)", Qt::red);
    m1->internalAddNode(QPointF(0, 0));
    m1->internalAddNode(QPointF(2000, 50)); // 1번: 2 -> 2000
    MotorProfile* m2 = m_document->addMotor("Motor 4 (Blue)", Qt::blue);
    m2->internalAddNode(QPointF(500, -30)); // 1번: 0.5 -> 500
    m2->internalAddNode(QPointF(1500, 80)); // 1번: 1.5 -> 1500

    onDocumentModelChanged(); 
    
// ... (생성자 하단부) ...

// ... (다른 함수들은 그대로 둡니다) ...

void MainWindow::onExportDocument() {
    if (!m_document) return;

    // 1. 다이얼로그 생성 (샘플링 전용)
    QDialog dialog(this);
    dialog.setWindowTitle("샘플링하여 내보내기");
    QVBoxLayout layout(&dialog);
    QLabel* infoLabel = new QLabel("모든 모터를 샘플링하여 YAML 파일로 내보냅니다.");
    layout.addWidget(infoLabel);

    // 샘플링 옵션용 위젯
    QWidget* optionsWidget = new QWidget;
    QFormLayout* optionsLayout = new QFormLayout(optionsWidget);
    QDoubleSpinBox* endTimeSpin = new QDoubleSpinBox;
    endTimeSpin->setRange(0.0, 100000.0); // 1번: 범위 10000 -> 100000
    endTimeSpin->setValue(2000.0); // 1번: 2.0 -> 2000.0
    // 가장 긴 모션 시간으로 기본값 설정
    double maxTime = 0.0;
    for (MotorProfile* p : m_document->motorProfiles()) {
        if (!p->nodes().isEmpty() && p->nodes().last().x() > maxTime) {
            maxTime = p->nodes().last().x();
        }
    }
    if (maxTime < 2000.0) maxTime = 2000.0; // 1번: 2.0 -> 2000.0
    endTimeSpin->setValue(maxTime);
    endTimeSpin->setSuffix(" ms"); // 1번: s -> ms
    QSpinBox* hzSpin = new QSpinBox;
// ... (파일 하단부) ...

