네, 4가지 요청 사항을 모두 반영하여 코드를 수정했습니다.
전체 파일을 다시 보내드리는 대신, 수정이 필요한 5개의 파일과 변경할 내용을 정확히 알려드립니다. 기존 코드를 열고 아래 설명에 따라 수정하시면 됩니다.
1. graphnodeitem.h (수정)
이 파일은 변경할 필요가 없습니다. 요청하신 3번 기능(선택된 노드 우클릭)은 .cpp 파일에서만 수정됩니다.
2. graphnodeitem.cpp (수정)
**1번(X좌표 >= 0)**과 3번(선택된 노드만 우클릭) 기능을 구현합니다.
contextMenuEvent 함수 수정:
함수 맨 위에 if (!isSelected()) 체크를 추가합니다.
// 1. 우클릭 메뉴
void GraphNodeItem::contextMenuEvent(QGraphicsSceneContextMenuEvent *event) {
    // 3번: 선택된 상태가 아니면 무시 (뷰의 contextMenu가 처리하도록)
    if (!isSelected()) {
        event->ignore();
        return;
    }
    
    QMenu menu;
// ... (이하 동일)

itemChange 함수 수정:
qBound를 호출하기 전에 X좌표를 0 이상으로 제한하는 qMax를 추가합니다.
// 스냅 기능 추가 (Feature 3b)
QVariant GraphNodeItem::itemChange(GraphicsItemChange change, const QVariant& value) {
    if (change == ItemPositionChange && scene()) {
        QPointF newPos = value.toPointF();

        // 1. 스냅 기능 (기존)
        if (m_view && m_view->isSnapEnabled()) {
            // ... (기존 스냅 로직) ...
        }

        // 1번: X좌표는 0 이하로 내려가지 않음
        newPos.setX(qMax(0.0, newPos.x()));

        // 2. Y축 제한 (기존)
        double clampedY = qBound(m_profile->yMin(), newPos.y(), m_profile->yMax());
        newPos.setY(clampedY);
        
        return newPos;
    }
    return QGraphicsItem::itemChange(change, value);
}

onEditTriggered 함수 수정:
X(시간) 스핀박스의 최소 범위를 0으로 설정합니다.
// 7. 좌표 동시 편집 -> MoveNodeCommand 생성
void GraphNodeItem::onEditTriggered() {
    // ... (QDialog dialog; QFormLayout layout(&dialog);) ...
    
    QDoubleSpinBox* xSpin = new QDoubleSpinBox();
    xSpin->setDecimals(3);
    // 1번: X좌표(시간)의 최소값을 0으로 설정
    xSpin->setRange(0.0, 100000.0);
    xSpin->setValue(currentNode.x());
// ... (이하 동일)

3. grapheditorview.cpp (수정)
**1번(새 노드 X >= 0)**과 2번(축 숫자 표시) 기능을 구현합니다.
contextMenuEvent 함수 수정:
새 노드 추가 시 X좌표를 검사하는 로직을 추가합니다.
// 2. 우클릭 -> AddNodeCommand 생성
void GraphNodeItem::contextMenuEvent(QContextMenuEvent* event) {
    if (!m_document || !m_document->activeProfile() || !m_undoStack) return;

    QPointF scenePos = mapToScene(event->pos());
    MotorProfile* activeProfile = m_document->activeProfile();
// ... (QMenu menu; QAction* addAction ...)

    // 1번: X좌표가 0 미만인 곳에는 노드 추가 비활성화
    if (scenePos.x() < 0) {
        addAction->setEnabled(false);
        addAction->setText(addAction->text() + " (X < 0 불가)");
    }
    // Y축 제한 (기존)
    else if (scenePos.y() < activeProfile->yMin() || scenePos.y() > activeProfile->yMax()) {
// ... (이하 동일)

drawBackground 함수 수정:
함수 맨 마지막(닫는 중괄호 } 직전)에 축 숫자를 그리는 코드를 추가합니다.
void GraphEditorView::drawBackground(QPainter* painter, const QRectF& rect) {
    QGraphicsView::drawBackground(painter, rect);
    // ... (기존 그리드 라인 그리기 로직) ...
    painter->drawLine(QPointF(rect.left(), 0), QPointF(rect.right(), 0)); // X축
    
    // 2번: 축 숫자 값 표시
    painter->setPen(QPen(Qt::black));
    // 폰트 크기가 줌에 따라 변하지 않도록 설정 (Cosmetic Pen과 유사)
    QFont font = painter->font();
    font.setPointSizeF(8); // 8pt 크기
    painter->setFont(font);

    // 씬 좌표 기준으로 그리드 시작점/간격 가져오기 (기존 코드 재사용)
    double gridSize = m_gridSize;
    double left = qFloor(rect.left() / gridSize) * gridSize;
    double top = qFloor(rect.top() / gridSize) * gridSize;

    // Y=0 (X축)을 따라 숫자 표시
    for (double x = left; x < rect.right(); x += gridSize) {
        if (qAbs(x) > 1e-3) { // 0은 그리지 않음
            // X, Y, Width, Height, Align, Text
            painter->drawText(QRectF(x - 50, 2, 100, 20), Qt::AlignHCenter | Qt::AlignTop, QString::number(x));
        }
    }
    
    // X=0 (Y축)을 따라 숫자 표시
    for (double y = top; y < rect.bottom(); y += gridSize) {
        if (qAbs(y) > 1e-3) { // 0은 그리지 않음
             painter->drawText(QRectF(2, y - 10, 50, 20), Qt::AlignLeft | Qt::AlignVCenter, QString::number(y));
        }
    }
}

4. motionmodels.h (수정)
**4번(JSON 내보내기)**을 위해 MotorProfile에 새 함수를 선언합니다.
// ... (MotorProfile 클래스 내부) ...
class MotorProfile : public QObject {
// ...
public:
    // ... (기존 함수들) ...
    void write(QJsonObject& json) const; // 기존 "노드만" 저장 함수

    // 4번: "샘플링"된 데이터를 JSON으로 내보내는 새 함수
    void exportSamplesToJSON(QJsonObject& json, double sampleRateHz, double endTimeSec) const;

    // --- Undo/Redo를 위한 공개 내부 함수 ---
// ...

5. motionmodels.cpp (수정)
**4번(JSON 내보내기)**을 위해 MotorProfile에 새 함수를 구현합니다.
// ... (파일 상단)
#include <QJsonArray>
#include <QFile>
#include <QDebug>
#include <algorithm>
#include <qmath.h>

// ... (MotorProfile의 기존 함수들) ...

// 4번: "샘플링"된 데이터를 JSON으로 내보내는 새 함수 구현
void MotorProfile::exportSamplesToJSON(QJsonObject& json, double sampleRateHz, double endTimeSec) const {
    json["name"] = m_name; // 이름은 동일하게
    
    QJsonArray nodesArray;
    if (sampleRateHz <= 0 || endTimeSec < 0) {
        json["nodes"] = nodesArray; // 빈 배열
        return;
    }

    double dt = 1.0 / sampleRateHz;
    
    // X=0 제약조건: 0초부터 샘플링 시작
    for (double time = 0.0; time <= endTimeSec; time += dt) {
        double value = sampleAt(time); // 기존 보간 함수 사용
        QJsonObject nodeObj;
        nodeObj["time"] = time;
        nodeObj["value"] = value;
        nodesArray.append(nodeObj);
    }
    
    // 마지막 샘플 포함 보장
    // (fmod 대신 시간차로 비교하여 부동소수점 오류 방지)
    double lastSampleTime = (qFloor(endTimeSec / dt)) * dt;
    if (endTimeSec - lastSampleTime > 1e-6 && endTimeSec > 0.0) {
        double value = sampleAt(endTimeSec);
        QJsonObject nodeObj;
        nodeObj["time"] = endTimeSec;
        nodeObj["value"] = value;
        nodesArray.append(nodeObj);
    } else if (endTimeSec == 0.0) { // 0초만 내보내기
        double value = sampleAt(0.0);
        QJsonObject nodeObj;
        nodeObj["time"] = 0.0;
        nodeObj["value"] = value;
        nodesArray.append(nodeObj);
    }
    
    json["nodes"] = nodesArray;
}


// --- MotionDocument 구현 ---
// ...

6. mainwindow.cpp (수정)
**4번(JSON 내보내기)**을 위해 onExportDocument 함수를 수정합니다.
// ... (includes) ...
#include <QTextStream> // 이 include는 이제 필요 없습니다. 삭제해도 됩니다.
#include <QDebug> // qrand

// ... (MainWindow 생성자 및 다른 함수들) ...


// --- 2. Export 다이얼로그 로직 ---
void MainWindow::onExportDocument() {
    if (!m_document || !m_document->activeProfile()) {
        QMessageBox::warning(this, "내보내기 오류", "선택된 모터가 없습니다.");
        return;
    }

    // 1. 다이얼로그 생성 (기존과 동일)
    QDialog dialog(this);
    // ... (QRadioButton, QSpinBox 등 기존과 동일) ...
    
    // 2. 다이얼로그 실행 (기존과 동일)
    if (dialog.exec() != QDialog::Accepted) {
        return;
    }

    // 3. 파일 경로 묻기 (4번: CSV가 아닌 JSON으로 변경)
    QString fileName = QFileDialog::getSaveFileName(this, "내보내기", "", "JSON 파일 (*.json)");
    if (fileName.isEmpty()) return;

    QFile file(fileName);
    if (!file.open(QIODevice::WriteOnly)) { // 4번: QIODevice::Text 제거
        QMessageBox::warning(this, "파일 오류", "파일을 열 수 없습니다.");
        return;
    }
    
    // QTextStream stream(&file); // 4번: QTextStream 대신 QJsonDocument 사용

    // 4. 선택된 옵션에 따라 JSON 객체 생성
    QJsonObject rootObj;
    QJsonArray motorsArray;
    
    MotorProfile* activeProfile = m_document->activeProfile();
    bool useSampling = sampledRadio->isChecked();
    
    for (MotorProfile* profile : m_document->motorProfiles()) {
        QJsonObject motorObj;
        
        // 활성 모터이고 "샘플링"이 선택된 경우에만 샘플링
        if (useSampling && profile == activeProfile) {
            profile->exportSamplesToJSON(motorObj, hzSpin->value(), endTimeSpin->value());
        } else {
            // 그 외 모든 모터는 "노드만" 내보내기 (기존 save와 동일)
            profile->write(motorObj);
        }
        motorsArray.append(motorObj);
    }
    
    rootObj["motors"] = motorsArray;
    
    // 4번: JSON 파일로 저장
    file.write(QJsonDocument(rootObj).toJson());
    file.close();
    
    statusBar()->showMessage("내보내기 완료.", 2000);
}

