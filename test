ë„¤, 4ê°€ì§€ ìš”ì²­ ì‚¬í•­ì„ ë°˜ì˜í•˜ì—¬ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ê² ìŠµë‹ˆë‹¤.
 * ëª¨í„° ë³€ê²½ ì‹œ Yì¶• ë ˆì´ë¸” ê°±ì‹ : grapheditorview.cppì˜ setDocument í•¨ìˆ˜ì— activeMotorChanged ì‹œê·¸ë„ê³¼ update() ìŠ¬ë¡¯ ì—°ê²° ì½”ë“œê°€ ì´ë¯¸ ìˆìœ¼ë¯€ë¡œ, ëª¨í„°ê°€ ë³€ê²½ë˜ë©´ ìë™ìœ¼ë¡œ drawBackgroundê°€ í˜¸ì¶œë˜ì–´ ë ˆì´ë¸”ì´ ê°±ì‹ ë©ë‹ˆë‹¤. (ì¶”ê°€ ìˆ˜ì • í•„ìš” ì—†ìŒ)
 * ì¤Œ/íŒ¬ ì‹œ ë ˆì´ë¸” ê°±ì‹ : QGraphicsViewëŠ” ì¤Œ/íŒ¬ ì‹œ ìë™ìœ¼ë¡œ drawBackgroundë¥¼ í˜¸ì¶œí•˜ë¯€ë¡œ ë ˆì´ë¸”ì´ ê°±ì‹ ë©ë‹ˆë‹¤. (ì¶”ê°€ ìˆ˜ì • í•„ìš” ì—†ìŒ)
 * ë ˆì´ë¸” ê¸€ì í¬ê¸° ê³ ì •: grapheditorview.cppì˜ drawBackground í•¨ìˆ˜ì—ì„œ ë·°ì˜ í˜„ì¬ ìŠ¤ì¼€ì¼(í™•ëŒ€/ì¶•ì†Œ ë¹„ìœ¨)ì„ ì–»ì–´ì™€ í°íŠ¸ í¬ê¸°ë¥¼ ë™ì ìœ¼ë¡œ ì¡°ì ˆí•˜ì—¬ í™”ë©´ìƒ í¬ê¸°ê°€ ì¼ì •í•˜ê²Œ ë³´ì´ë„ë¡ ìˆ˜ì •í•©ë‹ˆë‹¤.
 * ìµœëŒ€ ê¸°ìš¸ê¸° ì œì•½ì¡°ê±´ ì ìš©: motionmodels.cppì˜ MotorProfile::checkAllNodes í•¨ìˆ˜ì— ê¸°ìš¸ê¸° ê²€ì‚¬ ë° ë…¸ë“œ Yì¢Œí‘œ ì¡°ì • ë¡œì§ì„ ì¶”ê°€í•©ë‹ˆë‹¤. ê¸°ìš¸ê¸°ëŠ” ì´ì „ ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê³„ì‚°í•˜ë©°, max_slopeë¥¼ ì´ˆê³¼í•˜ë©´ í˜„ì¬ ë…¸ë“œì˜ Yê°’ì„ ì¡°ì •í•©ë‹ˆë‹¤.
1. grapheditorview.cpp (ìˆ˜ì •)
drawBackground í•¨ìˆ˜ë¥¼ ìˆ˜ì •í•˜ì—¬ ê¸€ì í¬ê¸°ë¥¼ ê³ ì •í•˜ê³ , checkAllNodes í•¨ìˆ˜ì—ì„œ ê¸°ìš¸ê¸° ì œí•œ ë¡œì§ì„ ì¶”ê°€í•©ë‹ˆë‹¤.
// grapheditorview.cpp

#include "grapheditorview.h"
// ... (ë‹¤ë¥¸ includeë“¤) ...
#include <QTransform>
#include <QPainter> // QPainter ì‚¬ìš©ì„ ìœ„í•´ ëª…ì‹œì  include (ì„ íƒì )

// ... (ìƒì„±ì ë° ë‹¤ë¥¸ í•¨ìˆ˜ë“¤) ...

// 3ë²ˆ: ë ˆì´ë¸” ê¸€ì í¬ê¸° ê³ ì •
void GraphEditorView::drawBackground(QPainter* painter, const QRectF& rect) {
    QGraphicsView::drawBackground(painter, rect);
    // --- ê·¸ë¦¬ë“œ ë¼ì¸ ê·¸ë¦¬ê¸° (ê¸°ì¡´ê³¼ ë™ì¼) ---
    QPen gridPen(QColor(220, 220, 220), 0);
    gridPen.setCosmetic(true);
    painter->setPen(gridPen);
    double left_x = qFloor(rect.left() / m_gridSizeX) * m_gridSizeX;
    for (double x = left_x; x < rect.right(); x += m_gridSizeX) {
        painter->drawLine(QPointF(x, rect.top()), QPointF(x, rect.bottom()));
    }
    double top_y = qFloor(rect.top() / m_gridSizeY) * m_gridSizeY;
    for (double y = top_y; y < rect.bottom(); y += m_gridSizeY) {
        painter->drawLine(QPointF(rect.left(), y), QPointF(rect.right(), y));
    }
    // --- ì¶•ì„  ê·¸ë¦¬ê¸° (ê¸°ì¡´ê³¼ ë™ì¼) ---
    QPen axisPen(QColor(180, 180, 180), 0);
    axisPen.setCosmetic(true);
    painter->setPen(axisPen);
    painter->drawLine(QPointF(0, rect.top()), QPointF(0, rect.bottom())); // Yì¶•
    painter->drawLine(QPointF(rect.left(), 0), QPointF(rect.right(), 0)); // Xì¶•


    painter->save();
    painter->scale(1, -1); // Yì¶• ë°˜ì „

    painter->setPen(QPen(Qt::black));
    QFont font = painter->font();

    // 3ë²ˆ: í˜„ì¬ ë·°ì˜ ìŠ¤ì¼€ì¼(Yì¶• ê¸°ì¤€)ì„ ì–»ì–´ì™€ í°íŠ¸ í¬ê¸° ì¡°ì •
    qreal currentScaleY = transform().m22(); // Y ìŠ¤ì¼€ì¼ ê°’ (ë°˜ì „ìœ¼ë¡œ ìŒìˆ˜ì¼ ìˆ˜ ìˆìŒ)
    qreal scaleFactor = qAbs(currentScaleY) > 1e-6 ? 1.0 / qAbs(currentScaleY) : 1.0;
    font.setPointSizeF(8 * scaleFactor); // ê¸°ë³¸ 8pt * ìŠ¤ì¼€ì¼ ì—­ìˆ˜
    painter->setFont(font);

    MotorProfile* activeProfile = m_document ? m_document->activeProfile() : nullptr;

    // --- Xì¶• ë ˆì´ë¸” (ê¸°ì¡´ê³¼ ë™ì¼) ---
    double xLabelInterval = 0.5; // 500ms
    double startXLabel = qFloor(rect.left() / xLabelInterval) * xLabelInterval;
    for (double x = startXLabel; x < rect.right(); x += xLabelInterval) {
        QString xLabel = QString::number(x, 'f', (qAbs(x - qRound(x)) < 1e-3) ? 0 : 1) + "s";
        if (qAbs(x) > 1e-3 || qAbs(xLabelInterval - (qAbs(rect.left()) + qAbs(rect.right()))) < 1e-3) {
             // 3ë²ˆ: Yì¶• ë°˜ì „ + ìŠ¤ì¼€ì¼ ë³´ì •ëœ ìœ„ì¹˜ ê³„ì‚°
             QRectF textRect(x - 50 * scaleFactor, 2 * scaleFactor, 100 * scaleFactor, 20 * scaleFactor);
             painter->drawText(textRect, Qt::AlignHCenter | Qt::AlignTop, xLabel);
        }
    }

    // --- Yì¶• ë ˆì´ë¸” (ê¸°ì¡´ê³¼ ë™ì¼) ---
    double yLabelInterval = m_gridSizeY; // ì”¬ ì¢Œí‘œ 10 ê°„ê²©
    double startYLabel = qFloor(rect.top() / yLabelInterval) * yLabelInterval;
    for (double y_scene = startYLabel; y_scene < rect.bottom(); y_scene += yLabelInterval) {
        if (qAbs(y_scene) > 1e-3 || qAbs(yLabelInterval - (qAbs(rect.top()) + qAbs(rect.bottom()))) < 1e-3) {
             QString label;
             if (activeProfile) {
                double y_real = activeProfile->getRealY(y_scene);
                label = QString::number(y_real, 'f', 1);
             } else {
                label = QString::number(y_scene);
             }
             // 3ë²ˆ: Yì¶• ë°˜ì „ + ìŠ¤ì¼€ì¼ ë³´ì •ëœ ìœ„ì¹˜ ê³„ì‚°
             QRectF textRect(2 * scaleFactor, -y_scene - 10 * scaleFactor, 50 * scaleFactor, 20 * scaleFactor);
             painter->drawText(textRect, Qt::AlignLeft | Qt::AlignVCenter, label);
        }
    }

    painter->restore();
}

// ... (íŒŒì¼ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì€ ë³€ê²½ ì—†ìŒ) ...

2. motionmodels.cpp (ìˆ˜ì •)
MotorProfile::checkAllNodes í•¨ìˆ˜ì— ê¸°ìš¸ê¸° ì œí•œ ë¡œì§ì„ ì¶”ê°€í•©ë‹ˆë‹¤.
// motionmodels.cpp

#include "motionmodels.h"
// ... (ë‹¤ë¥¸ includeë“¤) ...
#include <qmath.h> // qBound, qAbs, fmod, qFloor

// ... (MotorProfile ìƒì„±ì ë° ë‹¤ë¥¸ í•¨ìˆ˜ë“¤) ...

// 4ë²ˆ: ì œì•½ì¡°ê±´ ì ìš© í•¨ìˆ˜ (ìµœëŒ€ ê¸°ìš¸ê¸° ë¡œì§ ì¶”ê°€)
void MotorProfile::checkAllNodes() {
    bool dataWasChanged = false;
    
    // ì²« ë²ˆì§¸ íŒ¨ìŠ¤: Y min/max ì ìš©
    for (int i = 0; i < m_nodes.size(); ++i) {
        MotionNode node = m_nodes[i];
        double oldY = node.y();
        double clampedY = qBound(m_y_min, oldY, m_y_max);
        
        if (oldY != clampedY) {
            node.setY(clampedY);
            m_nodes[i] = node; 
            dataWasChanged = true;
        }
    }
    
    // ë‘ ë²ˆì§¸ íŒ¨ìŠ¤: ìµœëŒ€ ê¸°ìš¸ê¸° ì ìš© (0ë²ˆ ë…¸ë“œëŠ” ê¸°ì¤€ì ì´ë¯€ë¡œ 1ë²ˆë¶€í„° ì‹œì‘)
    for (int i = 1; i < m_nodes.size(); ++i) {
        MotionNode& prevNode = m_nodes[i-1];
        MotionNode& currNode = m_nodes[i];
        
        double deltaX = currNode.x() - prevNode.x();
        
        // ë‘ ë…¸ë“œì˜ Xì¢Œí‘œê°€ ê°™ìœ¼ë©´ ê¸°ìš¸ê¸° ê³„ì‚° ë¶ˆê°€ (ë¬´ì‹œ)
        if (qAbs(deltaX) < 1e-6) {
            continue; 
        }
        
        double deltaY = currNode.y() - prevNode.y();
        double currentSlope = deltaY / deltaX;
        
        // ìµœëŒ€ ê¸°ìš¸ê¸°(ì ˆëŒ“ê°’) ì´ˆê³¼ ê²€ì‚¬
        if (qAbs(currentSlope) > m_max_slope) {
            // ìµœëŒ€ ê¸°ìš¸ê¸°ì— ë§ì¶° í˜„ì¬ ë…¸ë“œ(currNode)ì˜ Yê°’ ì¡°ì •
            double newDeltaY = qBound(-m_max_slope, currentSlope, m_max_slope) * deltaX;
            double newY = prevNode.y() + newDeltaY;
            
            // ì¡°ì •ëœ Yê°’ì´ min/max ë²”ìœ„ ì•ˆì— ìˆë„ë¡ ë‹¤ì‹œ ì œí•œ
            newY = qBound(m_y_min, newY, m_y_max);
            
            if (qAbs(currNode.y() - newY) > 1e-6) {
                currNode.setY(newY);
                dataWasChanged = true;
                qDebug() << "Node" << i << " adjusted for slope constraint. New Y:" << newY;
            }
        }
    }

    if (dataWasChanged) {
        // sortNodes(); // Yê°’ë§Œ ë°”ë€Œì—ˆìœ¼ë¯€ë¡œ ì •ë ¬ ë¶ˆí•„ìš”
        emit dataChanged(); // ë·° ê°±ì‹ 
    }
}

// ... (íŒŒì¼ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì€ ë³€ê²½ ì—†ìŒ) ...

3. mainwindow.cpp (ìˆ˜ì •)
onActiveMotorSwitched í•¨ìˆ˜ ë‚´ì—ì„œ fitToActiveMotor í˜¸ì¶œ ë¶€ë¶„ì„ ë‹¤ì‹œ ì£¼ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
// mainwindow.cpp

// ... (includes) ...

// ... (ë‹¤ë¥¸ í•¨ìˆ˜ë“¤) ...

// 1ë²ˆ: ë·° ë³€ê²½(fit) ì½”ë“œ ì£¼ì„ ì²˜ë¦¬
void MainWindow::onActiveMotorSwitched(MotorProfile* active, MotorProfile* previous) {
    if (previous) {
        disconnectProfileFromSpinBoxes(previous);
    }
    if (active) {
        connectProfileToSpinBoxes(active);

        m_motorTreeWidget->blockSignals(true);
        for(int i=0; i < m_motorsRootItem->childCount(); ++i) {
            QTreeWidgetItem* item = m_motorsRootItem->child(i);
            MotorProfile* profile = item->data(0, Qt::UserRole).value<MotorProfile*>();
            if(profile == active) {
                m_motorTreeWidget->setCurrentItem(item);
                break;
            }
        }
        m_motorTreeWidget->blockSignals(false);

        // 1ë²ˆ: ì‹œì  ë³€ê²½ ì½”ë“œ ì£¼ì„ ì²˜ë¦¬
        // m_view->fitToActiveMotor(active);

    } else {
        // 1ë²ˆ: ì‹œì  ë³€ê²½ ì½”ë“œ ì£¼ì„ ì²˜ë¦¬
        // m_view->fitToActiveMotor(nullptr);
    }

    onNodeSelected(nullptr);
    m_undoStack->clear();
}

// ... (íŒŒì¼ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì€ ë³€ê²½ ì—†ìŒ) ...

ì´ ìˆ˜ì •ì‚¬í•­ë“¤ì„ ì ìš©í•˜ê³  ë‹¤ì‹œ ë¹Œë“œí•´ ë³´ì„¸ìš”. ğŸ‘







ë„¤, 3ê°€ì§€ ë¬¸ì œë¥¼ í•´ê²°í•˜ë„ë¡ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ê² ìŠµë‹ˆë‹¤.
 * íŒ¨ë‹ ë°©í–¥ ìˆ˜ì •: grapheditorview.cppì˜ mouseMoveEventì—ì„œ ìˆ˜í‰ ìŠ¤í¬ë¡¤ë°” ì¡°ì‘ ì½”ë“œë¥¼ ì œê±°í•˜ê³ , ìˆ˜ì§ ìŠ¤í¬ë¡¤ë°” ì¡°ì‘ë§Œ ë‚¨ê²¨ ìœ„ì•„ë˜ íŒ¨ë‹ë§Œ ê°€ëŠ¥í•˜ë„ë¡ í•©ë‹ˆë‹¤. (ì´ì „ ìš”ì²­ì—ì„œ Xì¶• ì¤‘ì•™ ê³ ì •ì„ ìœ„í•´ ìˆ˜í‰ íŒ¨ë‹ì„ ë¹„í™œì„±í™”í–ˆì—ˆìŠµë‹ˆë‹¤.)
 * Xì¶• ë¹„ìœ¨ ë³€ê²½: grapheditorview.hì—ì„œ m_gridSizeX ê¸°ë³¸ê°’ì„ 0.05 (50ms)ë¡œ ë³€ê²½í•˜ê³ , grapheditorview.cppì˜ drawBackgroundì—ì„œ ì´ ê°’ì„ ì‚¬ìš©í•˜ì—¬ ê·¸ë¦¬ë“œë¥¼ ê·¸ë¦¬ë„ë¡ í•©ë‹ˆë‹¤. ë ˆì´ë¸”ì€ ì—¬ì „íˆ 0.5ì´ˆ(500ms) ê°„ê²©ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤.
 * ëª¨í„° ì „í™˜ ì‹œ í™”ë©´ ê³ ì •: mainwindow.cppì˜ onActiveMotorSwitched í•¨ìˆ˜ ë‚´ì—ì„œ m_view->fitToActiveMotor(active); í˜¸ì¶œ ë¶€ë¶„ì„ ì£¼ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
ìˆ˜ì •ì´ í•„ìš”í•œ íŒŒì¼ì€ grapheditorview.h, grapheditorview.cpp, mainwindow.cpp ì…ë‹ˆë‹¤. ì•„ë˜ ì½”ë“œ ë¸”ë¡ì—ì„œ í•´ë‹¹ íŒŒì¼ë“¤ì˜ ìˆ˜ì •ëœ ë¶€ë¶„ë§Œ ë³´ì—¬ë“œë¦½ë‹ˆë‹¤. ê¸°ì¡´ ì½”ë“œë¥¼ ì—´ê³  í•´ë‹¹ ë¶€ë¶„ì„ ì°¾ì•„ êµì²´í•˜ì‹œë©´ ë©ë‹ˆë‹¤.
1. grapheditorview.h (ìˆ˜ì •)
m_gridSizeXì˜ ê¸°ë³¸ê°’ì„ ë³€ê²½í•©ë‹ˆë‹¤.
// grapheditorview.h
// ... (includes) ...

class GraphEditorView : public QGraphicsView {
    // ... (Q_OBJECT, public, signals, protected) ...

private slots:
    // ... (private slots) ...

private:
    // ... (private functions) ...
    
    // ... (m_constraintItems, m_undoStack, m_snapToGrid) ...

    // 3ë²ˆ: X, Y ê·¸ë¦¬ë“œ í¬ê¸° ë¶„ë¦¬ (Xì¶• ê¸°ë³¸ê°’ 0.05ë¡œ ë³€ê²½)
    double m_gridSizeX = 0.05; // 50ms (ì‹œê°„)
    double m_gridSizeY = 10.0; // ì •ê·œí™”ëœ Y (0~100)
    
    // ... (m_scene, m_document, m_profileItems, m_isPanning, m_panStartPos) ...
};

2. grapheditorview.cpp (ìˆ˜ì •)
mouseMoveEvent í•¨ìˆ˜ì™€ drawBackground í•¨ìˆ˜ë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤.
mouseMoveEvent í•¨ìˆ˜ ìˆ˜ì •:
ìˆ˜í‰ ìŠ¤í¬ë¡¤ë°” ì¡°ì‘ ì½”ë“œê°€ ì—†ëŠ”ì§€ í™•ì¸í•˜ê³ , ìˆ˜ì§ ìŠ¤í¬ë¡¤ë°”ë§Œ ì¡°ì‘í•˜ë„ë¡ í•©ë‹ˆë‹¤. (Yì¶• ë°˜ì „ì„ ê³ ë ¤í•˜ì—¬ + ê°€ ì•„ë‹Œ - ë¥¼ ì‚¬ìš©í•´ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í…ŒìŠ¤íŠ¸ í›„ ì¡°ì • í•„ìš”)
// grapheditorview.cpp

// ... (includes) ...

// ... (ë‹¤ë¥¸ í•¨ìˆ˜ë“¤) ...

// 1ë²ˆ, 2ë²ˆ: ìˆ˜í‰ íŒ¨ë‹ ì œí•œ, ìˆ˜ì§ íŒ¨ë‹ ë°©í–¥ ìˆ˜ì •
void GraphEditorView::mouseMoveEvent(QMouseEvent* event) {
    if (m_isPanning) {
        // ìˆ˜í‰ ìŠ¤í¬ë¡¤ë°” ì¡°ì‘ ì—†ìŒ (X=0 ì¤‘ì•™ ê³ ì •)
        // verticalScrollBar()->setValue(verticalScrollBar()->value() - (event->pos().y() - m_panStartPos.y()));
        // 1ë²ˆ: Yì¶• ë°˜ì „ì„ ê³ ë ¤í•˜ì—¬ (+) ë¡œ ë³€ê²½ ì‹œë„
        verticalScrollBar()->setValue(verticalScrollBar()->value() + (event->pos().y() - m_panStartPos.y()));
        m_panStartPos = event->pos();
        event->accept();
        return;
    }
    QGraphicsView::mouseMoveEvent(event);
}

// 3ë²ˆ: Xì¶• ê°„ê²© ë° ë ˆì´ë¸” ì¡°ì •
void GraphEditorView::drawBackground(QPainter* painter, const QRectF& rect) {
    QGraphicsView::drawBackground(painter, rect);
    QPen gridPen(QColor(220, 220, 220), 0);
    gridPen.setCosmetic(true);
    painter->setPen(gridPen);

    // 3ë²ˆ: Xì¶• ê·¸ë¦¬ë“œ (m_gridSizeX = 0.05 ì‚¬ìš©)
    double left_x = qFloor(rect.left() / m_gridSizeX) * m_gridSizeX;
    for (double x = left_x; x < rect.right(); x += m_gridSizeX) { // m_gridSizeX ê°„ê²©
        painter->drawLine(QPointF(x, rect.top()), QPointF(x, rect.bottom()));
    }
    // Yì¶• ê·¸ë¦¬ë“œ (ì”¬ ì¢Œí‘œ 10 ê°„ê²©)
    double top_y = qFloor(rect.top() / m_gridSizeY) * m_gridSizeY;
    for (double y = top_y; y < rect.bottom(); y += m_gridSizeY) {
        painter->drawLine(QPointF(rect.left(), y), QPointF(rect.right(), y));
    }

    // ì¶•ì„ 
    QPen axisPen(QColor(180, 180, 180), 0);
    axisPen.setCosmetic(true);
    painter->setPen(axisPen);
    painter->drawLine(QPointF(0, rect.top()), QPointF(0, rect.bottom())); // Yì¶•
    painter->drawLine(QPointF(rect.left(), 0), QPointF(rect.right(), 0)); // Xì¶•


    painter->save();
    painter->scale(1, -1);

    painter->setPen(QPen(Qt::black));
    QFont font = painter->font();
    font.setPointSizeF(8);
    painter->setFont(font);

    MotorProfile* activeProfile = m_document ? m_document->activeProfile() : nullptr;

    // 3ë²ˆ: Xì¶• ë ˆì´ë¸” (0.5ì´ˆ = 500ms ê°„ê²©)
    double xLabelInterval = 0.5; // 500ms
    double startXLabel = qFloor(rect.left() / xLabelInterval) * xLabelInterval;
    for (double x = startXLabel; x < rect.right(); x += xLabelInterval) {
        // ì†Œìˆ˜ì  ì•„ë˜ 0 ì œê±° + 's' ë‹¨ìœ„ ì¶”ê°€
        QString xLabel = QString::number(x, 'f', (qAbs(x - qRound(x)) < 1e-3) ? 0 : 1) + "s";
        if (qAbs(x) > 1e-3 || qAbs(xLabelInterval - (qAbs(rect.left()) + qAbs(rect.right()))) < 1e-3) {
             painter->drawText(QRectF(x - 50, 2, 100, 20), Qt::AlignHCenter | Qt::AlignTop, xLabel);
        }
    }

    // Yì¶• ë ˆì´ë¸” (ì”¬ ì¢Œí‘œ 10 ê°„ê²©)
    double yLabelInterval = m_gridSizeY;
    double startYLabel = qFloor(rect.top() / yLabelInterval) * yLabelInterval;
    for (double y_scene = startYLabel; y_scene < rect.bottom(); y_scene += yLabelInterval) {
        if (qAbs(y_scene) > 1e-3 || qAbs(yLabelInterval - (qAbs(rect.top()) + qAbs(rect.bottom()))) < 1e-3) {
             QString label;
             if (activeProfile) {
                double y_real = activeProfile->getRealY(y_scene);
                label = QString::number(y_real, 'f', 1);
             } else {
                label = QString::number(y_scene);
             }
             painter->drawText(QRectF(2, -y_scene - 10, 50, 20), Qt::AlignLeft | Qt::AlignVCenter, label);
        }
    }

    painter->restore();
}

// ... (íŒŒì¼ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì€ ë³€ê²½ ì—†ìŒ) ...

3. mainwindow.cpp (ìˆ˜ì •)
onActiveMotorSwitched í•¨ìˆ˜ ë‚´ì—ì„œ fitToActiveMotor í˜¸ì¶œ ë¶€ë¶„ì„ ì£¼ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
// mainwindow.cpp

// ... (includes) ...

// ... (ë‹¤ë¥¸ í•¨ìˆ˜ë“¤) ...

// 3ë²ˆ: ë·° ë³€ê²½(fit) ì½”ë“œ ì£¼ì„ ì²˜ë¦¬
void MainWindow::onActiveMotorSwitched(MotorProfile* active, MotorProfile* previous) {
    if (previous) {
        disconnectProfileFromSpinBoxes(previous);
    }
    if (active) {
        connectProfileToSpinBoxes(active);

        m_motorTreeWidget->blockSignals(true);
        for(int i=0; i < m_motorsRootItem->childCount(); ++i) {
            QTreeWidgetItem* item = m_motorsRootItem->child(i);
            MotorProfile* profile = item->data(0, Qt::UserRole).value<MotorProfile*>();
            if(profile == active) {
                m_motorTreeWidget->setCurrentItem(item);
                break;
            }
        }
        m_motorTreeWidget->blockSignals(false);

        // 3ë²ˆ: ì‹œì  ë³€ê²½ ì½”ë“œ ì£¼ì„ ì²˜ë¦¬
        // m_view->fitToActiveMotor(active);

    } else {
        // 3ë²ˆ: ì‹œì  ë³€ê²½ ì½”ë“œ ì£¼ì„ ì²˜ë¦¬
        // m_view->fitToActiveMotor(nullptr);
    }

    onNodeSelected(nullptr);
    m_undoStack->clear();
}

// ... (íŒŒì¼ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì€ ë³€ê²½ ì—†ìŒ) ...

ì´ ìˆ˜ì •ì‚¬í•­ë“¤ì„ ì ìš©í•˜ê³  ë‹¤ì‹œ ë¹Œë“œí•´ ë³´ì„¸ìš”. ğŸ‘








ë„¤, 5ê°€ì§€ ìš”ì²­ ì‚¬í•­ì„ ëª¨ë‘ ë°˜ì˜í•˜ì—¬ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ê² ìŠµë‹ˆë‹¤.
 * ëª¨í„° ì „í™˜ ì‹œ ê·¸ë˜í”„ ìœ„ì¹˜ ê³ ì •: mainwindow.cppì˜ onActiveMotorSwitched í•¨ìˆ˜ì—ì„œ fitToActiveMotor í˜¸ì¶œ ë¶€ë¶„ì„ ì£¼ì„ ì²˜ë¦¬í•˜ì—¬ ë·°ê°€ ìë™ìœ¼ë¡œ ë³€ê²½ë˜ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤.
 * Xì¶• ì¤‘ì•™ ê³ ì • ë° íŒ¨ë‹ ì œí•œ:
   * grapheditorview.cppì˜ fitToView, fitToActiveMotor í•¨ìˆ˜ ë§ˆì§€ë§‰ì— centerOn(0, sceneCenter().y())ë¥¼ í˜¸ì¶œí•˜ì—¬ X=0ì´ ì¤‘ì•™ì— ì˜¤ë„ë¡ í•©ë‹ˆë‹¤.
   * grapheditorview.cppì˜ mouseMoveEvent í•¨ìˆ˜ì—ì„œ íŒ¨ë‹ ì‹œ ìˆ˜í‰ ìŠ¤í¬ë¡¤ë°”(horizontalScrollBar())ë¥¼ ì¡°ì‘í•˜ëŠ” ì½”ë“œë¥¼ ì œê±°í•©ë‹ˆë‹¤.
 * Xì¶• ê°„ê²© ë° ë ˆì´ë¸” ì¡°ì •:
   * grapheditorview.hì— m_gridSizeX, m_gridSizeY ë©¤ë²„ ë³€ìˆ˜ë¥¼ ì¶”ê°€í•˜ê³  grapheditorview.cpp ìƒì„±ìì—ì„œ m_gridSizeX = 0.05 (50ms)ë¡œ ì„¤ì •í•©ë‹ˆë‹¤. (ì”¬ ì¢Œí‘œ 1 ë‹¨ìœ„ = 1ì´ˆ ê°€ì •)
   * grapheditorview.cppì˜ drawBackground í•¨ìˆ˜ì—ì„œ Xì¶• ê·¸ë¦¬ë“œëŠ” m_gridSizeX ê°„ê²©ìœ¼ë¡œ, ë ˆì´ë¸”ì€ m_gridSizeX * 10 (500ms) ê°„ê²©ìœ¼ë¡œ ê·¸ë¦¬ë„ë¡ ìˆ˜ì •í•©ë‹ˆë‹¤.
 * Xì¶•ë§Œ ì¤Œ: grapheditorview.cppì˜ wheelEvent í•¨ìˆ˜ì—ì„œ scale(scaleFactor, scaleFactor)ë¥¼ scale(scaleFactor, 1.0)ìœ¼ë¡œ ë³€ê²½í•˜ì—¬ Yì¶• ìŠ¤ì¼€ì¼ì€ ê³ ì •ì‹œí‚µë‹ˆë‹¤.
 * ìƒ˜í”Œë§ ë‚´ë³´ë‚´ê¸° ì‹œ ëª¨ë“  ëª¨í„° í¬í•¨: mainwindow.cppì˜ onExportDocument í•¨ìˆ˜ì—ì„œ "ìƒ˜í”Œë§í•˜ì—¬ ë‚´ë³´ë‚´ê¸°" ì˜µì…˜ ì„ íƒ ì‹œ, ëª¨ë“  ëª¨í„°ë¥¼ ìˆœíšŒí•˜ë©° exportSamplesToJSONì„ í˜¸ì¶œí•˜ì—¬ motorsArrayì— ì¶”ê°€í•˜ë„ë¡ ìˆ˜ì •í•©ë‹ˆë‹¤.
ì•„ë˜ 12ê°œ íŒŒì¼ì„ ê°ê° ë³µì‚¬í•˜ì—¬ ì‚¬ìš©í•˜ì‹œë©´ ë©ë‹ˆë‹¤.
1. CMakeLists.txt (ë³€ê²½ ì—†ìŒ)
cmake_minimum_required(VERSION 3.16)
project(MotionEditor_Qt5_v2 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(Qt5 REQUIRED COMPONENTS Core Gui Widgets)

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_INCLUDE_CURRENT_DIR ON)

# ì‹¤í–‰ íŒŒì¼ ìƒì„± (commands.cpp, commands.h ì¶”ê°€)
add_executable(MotionEditor
    main.cpp
    mainwindow.h
    mainwindow.cpp
    motionmodels.h
    motionmodels.cpp
    grapheditorview.h
    grapheditorview.cpp
    graphnodeitem.h
    graphnodeitem.cpp
    commands.h
    commands.cpp
)

target_link_libraries(MotionEditor PRIVATE
    Qt5::Core
    Qt5::Gui
    Qt5::Widgets
)

2. main.cpp (ë³€ê²½ ì—†ìŒ)
#include "mainwindow.h"
#include <QApplication>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.setWindowTitle("Profile Orchestrator (Qt 5)");
    w.show();
    return a.exec();
}

3. commands.h (ë³€ê²½ ì—†ìŒ)
#pragma once

#include <QUndoCommand>
#include <QPointF>
#include "motionmodels.h" // MotionNode, MotorProfile ì‚¬ìš©

// 1. ë…¸ë“œ ì¶”ê°€ ì»¤ë§¨ë“œ
class AddNodeCommand : public QUndoCommand {
public:
    AddNodeCommand(MotorProfile* profile, const MotionNode& node, QUndoCommand* parent = nullptr);
    void undo() override;
    void redo() override;
private:
    MotorProfile* m_profile;
    MotionNode m_node;
    int m_nodeIndex; // undoë¥¼ ìœ„í•´ ì¶”ê°€ëœ ì¸ë±ìŠ¤ ì €ì¥
};

// 2. ë…¸ë“œ ì‚­ì œ ì»¤ë§¨ë“œ
class DeleteNodeCommand : public QUndoCommand {
public:
    DeleteNodeCommand(MotorProfile* profile, int index, QUndoCommand* parent = nullptr);
    void undo() override;
    void redo() override;
private:
    MotorProfile* m_profile;
    MotionNode m_node; // ë³µì›ì„ ìœ„í•œ ë…¸ë“œ ë°ì´í„°
    int m_nodeIndex;
};

// 3. ë…¸ë“œ ì´ë™ ì»¤ë§¨ë“œ
class MoveNodeCommand : public QUndoCommand {
public:
    MoveNodeCommand(MotorProfile* profile, int index, const QPointF& oldPos, const QPointF& newPos, QUndoCommand* parent = nullptr);
    void undo() override;
    void redo() override;
    // ì—¬ëŸ¬ ê°œì˜ ì´ë™ì„ í•˜ë‚˜ë¡œ í•©ì¹˜ê¸° ìœ„í•œ í•¨ìˆ˜ (ë“œë˜ê·¸ ì‹œ ìœ ìš©)
    bool mergeWith(const QUndoCommand* command) override;
    int id() const override { return 1234; } // ë³‘í•©ì„ ìœ„í•œ ID

private:
    MotorProfile* m_profile;
    int m_nodeIndex;
    QPointF m_oldPos;
    QPointF m_newPos;
};

4. commands.cpp (ë³€ê²½ ì—†ìŒ)
#include "commands.h"
#include <QDebug>

// --- AddNodeCommand ---
AddNodeCommand::AddNodeCommand(MotorProfile* profile, const MotionNode& node, QUndoCommand* parent)
    : QUndoCommand(parent), m_profile(profile), m_node(node), m_nodeIndex(-1) {
    setText("ë…¸ë“œ ì¶”ê°€");
}

void AddNodeCommand::redo() {
    m_nodeIndex = m_profile->internalAddNode(m_node); // ë‚´ë¶€ í•¨ìˆ˜ í˜¸ì¶œ
    // m_profile->sortNodes(); // internalAddNodeê°€ ì •ë ¬ ë‹´ë‹¹
    m_profile->emitDataChanged(); // ë·° ê°±ì‹ 
}

void AddNodeCommand::undo() {
    if (m_nodeIndex != -1) {
        m_profile->internalRemoveNode(m_nodeIndex); // ë‚´ë¶€ í•¨ìˆ˜ í˜¸ì¶œ
        // sortNodes()ëŠ” í•„ìš” ì—†ìŒ
        m_profile->emitDataChanged(); // ë·° ê°±ì‹ 
    }
}

// --- DeleteNodeCommand ---
DeleteNodeCommand::DeleteNodeCommand(MotorProfile* profile, int index, QUndoCommand* parent)
    : QUndoCommand(parent), m_profile(profile), m_nodeIndex(index) {
    m_node = m_profile->nodeAt(index); // ì‚­ì œ ì „ ë…¸ë“œ ì •ë³´ ë°±ì—…
    setText("ë…¸ë“œ ì‚­ì œ");
}

void DeleteNodeCommand::redo() {
    m_profile->internalRemoveNode(m_nodeIndex);
    m_profile->emitDataChanged();
}

void DeleteNodeCommand::undo() {
    m_profile->internalAddNode(m_node); // ì‚­ì œí–ˆë˜ ë…¸ë“œ ë³µì›
    // m_profile->sortNodes(); // internalAddNodeê°€ ì •ë ¬ ë‹´ë‹¹
    m_profile->emitDataChanged();
}


// --- MoveNodeCommand ---
MoveNodeCommand::MoveNodeCommand(MotorProfile* profile, int index, const QPointF& oldPos, const QPointF& newPos, QUndoCommand* parent)
    : QUndoCommand(parent), m_profile(profile), m_nodeIndex(index), m_oldPos(oldPos), m_newPos(newPos) {
    setText("ë…¸ë“œ ì´ë™");
}

void MoveNodeCommand::redo() {
    m_profile->internalMoveNode(m_nodeIndex, m_newPos);
    m_profile->sortNodes();
    m_profile->emitDataChanged();
}

void MoveNodeCommand::undo() {
    m_profile->internalMoveNode(m_nodeIndex, m_oldPos);
    m_profile->sortNodes();
    m_profile->emitDataChanged();
}

// ë“œë˜ê·¸ ì¤‘ ë°œìƒí•˜ëŠ” ìˆ˜ë§ì€ ì´ë™ ì»¤ë§¨ë“œë¥¼ í•˜ë‚˜ë¡œ í•©ì¹©ë‹ˆë‹¤.
bool MoveNodeCommand::mergeWith(const QUndoCommand* command) {
    const MoveNodeCommand* moveCommand = static_cast<const MoveNodeCommand*>(command);
    // ê°™ì€ ë…¸ë“œì— ëŒ€í•œ ì´ë™ ì»¤ë§¨ë“œì¸ì§€ í™•ì¸
    if (moveCommand->id() != id() || moveCommand->m_nodeIndex != m_nodeIndex) {
        return false;
    }
    m_newPos = moveCommand->m_newPos; // ìµœì¢… ìœ„ì¹˜ë§Œ ê°±ì‹ 
    return true;
}

5. motionmodels.h (ë³€ê²½ ì—†ìŒ)
#pragma once

#include <QObject>
#include <QVector>
#include <QPointF>
#include <QString>
#include <QColor>
#include <QJsonObject>
#include <QVariant>
#include <QTextStream> // Exportìš©

using MotionNode = QPointF; 

// 2ë²ˆ: ì •ê·œí™”ëœ ì”¬(Scene)ì˜ Yì¶• ë²”ìœ„
const double NORMALIZED_Y_MIN = 0.0;
const double NORMALIZED_Y_MAX = 100.0;

class MotorProfile : public QObject {
    Q_OBJECT
    Q_PROPERTY(QString name READ name)
    Q_PROPERTY(QColor color READ color)

public:
    explicit MotorProfile(const QString& name, QColor color, QObject* parent = nullptr);

    // Getters
    const QString& name() const { return m_name; }
    const QColor& color() const { return m_color; }
    const QVector<MotionNode>& nodes() const { return m_nodes; }
    double yMin() const { return m_y_min; }
    double yMax() const { return m_y_max; }
    double maxSlope() const { return m_max_slope; }
    int nodeCount() const { return m_nodes.size(); }
    MotionNode nodeAt(int index) const;

    // Exportë¥¼ ìœ„í•œ ì„ í˜• ë³´ê°„ í•¨ìˆ˜
    double sampleAt(double time) const;

    // JSON ì§ë ¬í™”/ì—­ì§ë ¬í™”
    void read(const QJsonObject& json);
    void write(QJsonObject& json) const; 
    void exportSamplesToJSON(QJsonObject& json, double sampleRateHz, double endTimeSec) const;
    
    // 2ë²ˆ: Yì¶• ì •ê·œí™” ë³€í™˜ í•¨ìˆ˜
    double getNormalizedY(double realY) const;
    double getRealY(double normalizedY) const;

    // --- Undo/Redoë¥¼ ìœ„í•œ ê³µê°œ ë‚´ë¶€ í•¨ìˆ˜ ---
    int internalAddNode(const MotionNode& node);
    void internalRemoveNode(int index);
    void internalMoveNode(int index, const MotionNode& pos);
    void sortNodes(); 
    void emitDataChanged(); 

public slots:
    void setYMin(double val);
    void setYMax(double val);
    void setMaxSlope(double val);
    void checkAllNodes(); 

signals:
    void dataChanged(); 
    void constraintsChanged(); 

private:
    bool isNodeValid(const MotionNode& node, int indexToIgnore) const;

    QString m_name;
    QColor m_color;
    QVector<MotionNode> m_nodes; // ë…¸ë“œëŠ” í•­ìƒ "ì‹¤ì œ" ì¢Œí‘œë¡œ ì €ì¥

    double m_y_min = -100.0;
    double m_y_max = 100.0;
    double m_max_slope = 1000.0;
};

class MotionDocument : public QObject {
    Q_OBJECT

public:
    explicit MotionDocument(QObject* parent = nullptr);
    ~MotionDocument();

    const QVector<MotorProfile*>& motorProfiles() const { return m_profiles; }
    MotorProfile* activeProfile() const { return m_activeProfile; }
    int activeProfileIndex() const;

    // Export ë¡œì§
    bool exportNodesToStream(QTextStream& stream) const;
    bool exportSamplesToStream(QTextStream& stream, double sampleRateHz, double endTimeSec) const;

public slots:
    MotorProfile* addMotor(const QString& name, QColor color);
    void setActiveMotor(MotorProfile* profile); 
    void removeMotor(MotorProfile* profile);
    
    bool saveToFile(const QString& filename) const;
    bool loadFromFile(const QString& filename);

signals:
    void motorAdded(MotorProfile* profile);
    void documentCleared(); 
    void activeMotorChanged(MotorProfile* active, MotorProfile* previous);
    void modelChanged(); 

private:
    QVector<MotorProfile*> m_profiles;
    MotorProfile* m_activeProfile = nullptr;
};

Q_DECLARE_METATYPE(MotorProfile*)

6. motionmodels.cpp (ë³€ê²½ ì—†ìŒ)
#include "motionmodels.h"
#include <QJsonDocument>
#include <QJsonArray>
#include <QFile>
#include <QDebug>
#include <algorithm> // for std::sort
#include <qmath.h> // qBound, qAbs, fmod, qFloor

// --- MotorProfile êµ¬í˜„ ---
MotorProfile::MotorProfile(const QString& name, QColor color, QObject* parent)
    : QObject(parent), m_name(name), m_color(color) {
}

MotionNode MotorProfile::nodeAt(int index) const {
    if (index < 0 || index >= m_nodes.size()) {
        return MotionNode();
    }
    return m_nodes[index];
}

void MotorProfile::setYMin(double val) {
    if (m_y_min != val) {
        m_y_min = val;
        emit constraintsChanged();
    }
}
void MotorProfile::setYMax(double val) {
    if (m_y_max != val) {
        m_y_max = val;
        emit constraintsChanged();
    }
}
void MotorProfile::setMaxSlope(double val) {
    if (m_max_slope != val) {
        m_max_slope = val;
        emit constraintsChanged();
    }
}

// 6. ì œì•½ì¡°ê±´ ì ìš© í•¨ìˆ˜
void MotorProfile::checkAllNodes() {
    bool dataWasChanged = false;
    for (int i = 0; i < m_nodes.size(); ++i) {
        MotionNode node = m_nodes[i];
        double oldY = node.y();
        double clampedY = qBound(m_y_min, oldY, m_y_max);
        
        if (oldY != clampedY) {
            node.setY(clampedY);
            m_nodes[i] = node; 
            dataWasChanged = true;
        }
    }
    if (dataWasChanged) {
        sortNodes(); 
        emit dataChanged(); 
    }
}

// Exportìš© ì„ í˜• ë³´ê°„ í•¨ìˆ˜
double MotorProfile::sampleAt(double time) const {
    if (m_nodes.isEmpty()) return 0.0;
    if (time < 0.0) return 0.0; 
    
    const MotionNode* prev = nullptr;
    const MotionNode* next = nullptr;
    
    for (int i = 0; i < m_nodes.size(); ++i) {
        if (m_nodes[i].x() <= time) {
            prev = &m_nodes[i];
        } else {
            next = &m_nodes[i];
            break;
        }
    }
    
    if (!prev) {
        const MotionNode& firstNode = m_nodes.first();
        if (firstNode.x() < 1e-6) return firstNode.y();
        double t = time / firstNode.x();
        return 0.0 * (1.0 - t) + firstNode.y() * t;
    }
    if (!next) return m_nodes.last().y();  

    if (qAbs(next->x() - prev->x()) < 1e-6) {
        return prev->y(); 
    }
    
    double t = (time - prev->x()) / (next->x() - prev->x());
    return prev->y() * (1.0 - t) + next->y() * t;
}

// 4. íŒŒì¼ ì“°ê¸° (ì´ë¦„, ë…¸ë“œë§Œ)
void MotorProfile::write(QJsonObject& json) const {
    json["name"] = m_name;

    QJsonArray nodesArray;
    for (const MotionNode& node : m_nodes) {
        QJsonObject nodeObj;
        nodeObj["time"] = node.x();
        nodeObj["value"] = node.y();
        nodesArray.append(nodeObj);
    }
    json["nodes"] = nodesArray;
}

// 4ë²ˆ: "ìƒ˜í”Œë§"ëœ ë°ì´í„°ë¥¼ JSONìœ¼ë¡œ ë‚´ë³´ë‚´ëŠ” ìƒˆ í•¨ìˆ˜ êµ¬í˜„
void MotorProfile::exportSamplesToJSON(QJsonObject& json, double sampleRateHz, double endTimeSec) const {
    json["name"] = m_name; 
    
    QJsonArray nodesArray;
    if (sampleRateHz <= 0 || endTimeSec < 0) {
        json["nodes"] = nodesArray; 
        return;
    }

    double dt = 1.0 / sampleRateHz;
    
    for (double time = 0.0; time <= endTimeSec; time += dt) {
        double value = sampleAt(time); 
        QJsonObject nodeObj;
        nodeObj["time"] = time;
        nodeObj["value"] = value;
        nodesArray.append(nodeObj);
    }
    
    double lastSampleTime = (qFloor(endTimeSec / dt)) * dt;
    if (endTimeSec - lastSampleTime > 1e-6 && endTimeSec > 0.0) {
        double value = sampleAt(endTimeSec);
        QJsonObject nodeObj;
        nodeObj["time"] = endTimeSec;
        nodeObj["value"] = value;
        nodesArray.append(nodeObj);
    } else if (endTimeSec == 0.0 && dt > 0.0) { 
        double value = sampleAt(0.0);
        QJsonObject nodeObj;
        nodeObj["time"] = 0.0;
        nodeObj["value"] = value;
        nodesArray.append(nodeObj);
    }
    
    json["nodes"] = nodesArray;
}


// 3. íŒŒì¼ ì½ê¸°
void MotorProfile::read(const QJsonObject& json) {
    m_name = json["name"].toString(m_name);
    m_nodes.clear();
    QJsonArray nodesArray = json["nodes"].toArray();
    for (const QJsonValue& val : nodesArray) {
        QJsonObject nodeObj = val.toObject();
        m_nodes.append(MotionNode(nodeObj["time"].toDouble(), nodeObj["value"].toDouble()));
    }
    sortNodes();
}

bool MotorProfile::isNodeValid(const MotionNode& node, int indexToIgnore) const {
    if (node.x() < 0.0) {
        qDebug() << "Xì¶• ì œí•œ ìœ„ë°˜:" << node.x();
        return false;
    }
    if (node.y() < m_y_min || node.y() > m_y_max) {
        qDebug() << "Yì¶• ì œí•œ ìœ„ë°˜:" << node.y();
        return false;
    }
    Q_UNUSED(indexToIgnore); 
    return true;
}

// 2ë²ˆ: Yì¶• ì •ê·œí™” í•¨ìˆ˜
double MotorProfile::getNormalizedY(double realY) const
{
    double range = m_y_max - m_y_min;
    if (qAbs(range) < 1e-6) {
        return NORMALIZED_Y_MIN + (NORMALIZED_Y_MAX - NORMALIZED_Y_MIN) / 2.0; // ì¤‘ì•™ê°’
    }
    double normalized = (realY - m_y_min) / range;
    return NORMALIZED_Y_MIN + normalized * (NORMALIZED_Y_MAX - NORMALIZED_Y_MIN);
}

// 2ë²ˆ: Yì¶• ì—­ì •ê·œí™” í•¨ìˆ˜
double MotorProfile::getRealY(double normalizedY) const
{
    double normRange = NORMALIZED_Y_MAX - NORMALIZED_Y_MIN;
    if (qAbs(normRange) < 1e-6) {
        return m_y_min;
    }
    double normalized = (normalizedY - NORMALIZED_Y_MIN) / normRange;
    return m_y_min + normalized * (m_y_max - m_y_min);
}


// --- Undo/Redoìš© ë‚´ë¶€ í•¨ìˆ˜ ---
int MotorProfile::internalAddNode(const MotionNode& node) {
    m_nodes.append(node);
    sortNodes(); 
    return m_nodes.indexOf(node); 
}
void MotorProfile::internalRemoveNode(int index) {
    if (index >= 0 && index < m_nodes.size()) {
        m_nodes.remove(index);
    }
}
void MotorProfile::internalMoveNode(int index, const MotionNode& pos) {
    if (index >= 0 && index < m_nodes.size()) {
        m_nodes[index] = pos;
    }
}
void MotorProfile::sortNodes() {
    std::sort(m_nodes.begin(), m_nodes.end(), [](const MotionNode& a, const MotionNode& b) {
        return a.x() < b.x();
    });
}
void MotorProfile::emitDataChanged() {
    emit dataChanged();
}

// --- MotionDocument êµ¬í˜„ ---
MotionDocument::MotionDocument(QObject* parent) : QObject(parent) {}
MotionDocument::~MotionDocument() {
    qDeleteAll(m_profiles);
}
int MotionDocument::activeProfileIndex() const {
    if (!m_activeProfile) return -1;
    return m_profiles.indexOf(m_activeProfile);
}
MotorProfile* MotionDocument::addMotor(const QString& name, QColor color) {
    MotorProfile* profile = new MotorProfile(name, color, this);
    m_profiles.append(profile);
    emit motorAdded(profile);
    emit modelChanged();
    return profile;
}
void MotionDocument::setActiveMotor(MotorProfile* profile) {
    if (profile != m_activeProfile) {
        MotorProfile* oldActive = m_activeProfile;
        m_activeProfile = profile; 
        emit activeMotorChanged(m_activeProfile, oldActive);
    }
}
void MotionDocument::removeMotor(MotorProfile* profile) {
    if (!profile) return;
    int index = m_profiles.indexOf(profile);
    if (index == -1) return;
    m_profiles.removeAt(index);
    if (m_activeProfile == profile) {
        m_activeProfile = nullptr;
        if (!m_profiles.isEmpty()) {
            setActiveMotor(m_profiles.first());
        } else {
            setActiveMotor(nullptr); 
        }
    }
    emit modelChanged(); 
    profile->deleteLater(); 
}
bool MotionDocument::saveToFile(const QString& filename) const {
    QFile file(filename);
    if (!file.open(QIODevice::WriteOnly)) {
        qWarning() << "íŒŒì¼ ì“°ê¸° ì‹¤íŒ¨:" << filename;
        return false;
    }
    QJsonArray motorsArray;
    for (MotorProfile* profile : m_profiles) {
        QJsonObject motorObj;
        profile->write(motorObj);
        motorsArray.append(motorObj);
    }
    QJsonObject rootObj;
    rootObj["motors"] = motorsArray;
    file.write(QJsonDocument(rootObj).toJson());
    file.close();
    return true;
}
bool MotionDocument::loadFromFile(const QString& filename) {
    QFile file(filename);
    if (!file.open(QIODevice::ReadOnly)) {
        qWarning() << "íŒŒì¼ ì½ê¸° ì‹¤íŒ¨:" << filename;
        return false;
    }
    QByteArray data = file.readAll();
    QJsonDocument doc = QJsonDocument::fromJson(data);
    if (doc.isNull() || !doc.isObject()) {
        qWarning() << "ì˜ëª»ëœ JSON í˜•ì‹:" << filename;
        return false;
    }
    emit documentCleared();
    qDeleteAll(m_profiles);
    m_profiles.clear();
    m_activeProfile = nullptr;
    QJsonObject rootObj = doc.object();
    QJsonArray motorsArray = rootObj["motors"].toArray();
    for (const QJsonValue& val : motorsArray) {
        QJsonObject motorObj = val.toObject();
        QColor color = QColor::fromHsv(qrand() % 360, 200, 200); 
        MotorProfile* profile = new MotorProfile("", color, this); 
        profile->read(motorObj);
        m_profiles.append(profile);
        emit motorAdded(profile); 
    }
    emit modelChanged(); 
    if (!m_profiles.isEmpty()) {
        setActiveMotor(m_profiles.first());
    }
    return true;
}

// --- Export ë¡œì§ (CSVìš© - í˜„ì¬ ì‚¬ìš© ì•ˆ í•¨) ---
bool MotionDocument::exportNodesToStream(QTextStream& stream) const {
    if (!m_activeProfile) return false;
    stream << "Motor: " << m_activeProfile->name() << "\n";
    stream << "Time (s),Value\n";
    for (const MotionNode& node : m_activeProfile->nodes()) {
        stream << node.x() << "," << node.y() << "\n";
    }
    return true;
}
bool MotionDocument::exportSamplesToStream(QTextStream& stream, double sampleRateHz, double endTimeSec) const {
    if (!m_activeProfile || sampleRateHz <= 0) return false;
    stream << "Motor: " << m_activeProfile->name() << "\n";
    stream << "SampleRate: " << sampleRateHz << " Hz\n";
    stream << "Time (s),Value\n";
    double dt = 1.0 / sampleRateHz;
    if (m_activeProfile->nodes().isEmpty()) return true;
    double startTime = 0.0; // 0ì´ˆë¶€í„°
    if (endTimeSec < startTime) endTimeSec = m_activeProfile->nodes().last().x();
    for (double time = startTime; time <= endTimeSec; time += dt) {
        double value = m_activeProfile->sampleAt(time);
        stream << time << "," << value << "\n";
    }
    if (fmod(endTimeSec - startTime, dt) != 0.0) {
        double value = m_activeProfile->sampleAt(endTimeSec);
        stream << endTimeSec << "," << value << "\n";
    }
    return true;
}

7. graphnodeitem.h (ë³€ê²½ ì—†ìŒ)
#pragma once

#include <QGraphicsEllipseItem>
#include <QObject> 
#include <QPointF> // QPointF ì‚¬ìš©

class MotorProfile;
class GraphEditorView; // ë·° í¬ì¸í„° (ìŠ¤ëƒ…ìš©)
class QUndoStack; // Undo ìŠ¤íƒ í¬ì¸í„°

class GraphNodeItem : public QObject, public QGraphicsEllipseItem {
    Q_OBJECT

public:
    // ìƒì„±ì ìˆ˜ì •
    GraphNodeItem(MotorProfile* profile, int index, 
                  GraphEditorView* view, QUndoStack* stack, 
                  QGraphicsItem* parent = nullptr);
    
    MotorProfile* profile() const { return m_profile; }
    int index() const { return m_nodeIndex; }
    void setNodeIndex(int index) { m_nodeIndex = index; } 

protected:
    // 1. ìš°í´ë¦­
    void contextMenuEvent(QGraphicsSceneContextMenuEvent *event) override;
    // 1. ì¢Œí´ë¦­ ë“œë˜ê·¸ ì‹œì‘/ì¢…ë£Œ
    void mousePressEvent(QGraphicsSceneMouseEvent* event) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent* event) override;
    // 7. ìŠ¤ëƒ…
    QVariant itemChange(GraphicsItemChange change, const QVariant& value) override;

private slots:
    void onDeleteTriggered();

private:
    MotorProfile* m_profile;
    int m_nodeIndex;
    QPointF m_dragStartPosition; // 2ë²ˆ: ì”¬ ì¢Œí‘œ (ì •ê·œí™”ë¨)
    
    GraphEditorView* m_view; // ìŠ¤ëƒ… ê¸°ëŠ¥ìš©
    QUndoStack* m_undoStack; // Undo/Redoìš©
};

8. graphnodeitem.cpp (ë³€ê²½ ì—†ìŒ)
#include "graphnodeitem.h"
#include "grapheditorview.h" // ìŠ¤ëƒ… ê¸°ëŠ¥
#include "commands.h" // ì»¤ë§¨ë“œ
#include <QUndoStack> // Undo ìŠ¤íƒ
#include <QGraphicsSceneMouseEvent>
#include <QMenu>
#include <QPen>
#include <QBrush>
#include <QDebug>
#include <qmath.h> // qRound, qMax, qBound

// 2ë²ˆ: Yì¶• ì •ê·œí™”
GraphNodeItem::GraphNodeItem(MotorProfile* profile, int index, 
                             GraphEditorView* view, QUndoStack* stack, 
                             QGraphicsItem* parent)
    : QObject(nullptr), QGraphicsEllipseItem(parent), 
      m_profile(profile), m_nodeIndex(index), 
      m_view(view), m_undoStack(stack)
{
    setRect(-5, -5, 10, 10); 
    setPen(QPen(Qt::black, 1));
    setBrush(QBrush(profile->color()));
    setFlag(QGraphicsItem::ItemIsMovable);
    setFlag(QGraphicsItem::ItemSendsGeometryChanges); 
    setFlag(QGraphicsItem::ItemIsSelectable); 
    
    // 2ë²ˆ: "ì‹¤ì œ" ë…¸ë“œ ì¢Œí‘œë¥¼ ê°€ì ¸ì™€ "ì •ê·œí™”ëœ ì”¬" ì¢Œí‘œë¡œ ë³€í™˜í•˜ì—¬ ì„¤ì •
    MotionNode realNode = m_profile->nodeAt(m_nodeIndex);
    double sceneY = m_profile->getNormalizedY(realNode.y());
    setPos(realNode.x(), sceneY);
}

// 2ë²ˆ: ì”¬ ì¢Œí‘œ (ì •ê·œí™”ë¨)
void GraphNodeItem::mousePressEvent(QGraphicsSceneMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        m_dragStartPosition = pos(); // ì”¬ ì¢Œí‘œ
    }
    QGraphicsEllipseItem::mousePressEvent(event);
}

// 2ë²ˆ: MoveNodeCommandì— "ì‹¤ì œ" ì¢Œí‘œ ì „ë‹¬
void GraphNodeItem::mouseReleaseEvent(QGraphicsSceneMouseEvent* event) {
    QGraphicsEllipseItem::mouseReleaseEvent(event);
    
    if (event->button() == Qt::LeftButton && pos() != m_dragStartPosition) {
        // 1. "ì‹¤ì œ" ì´ì „ ì¢Œí‘œ
        QPointF oldRealPos = m_profile->nodeAt(m_nodeIndex);
        
        // 2. "ì‹¤ì œ" ìƒˆ ì¢Œí‘œ
        QPointF newScenePos = pos();
        double newRealY = m_profile->getRealY(newScenePos.y());
        QPointF newRealPos(newScenePos.x(), newRealY);

        m_undoStack->push(new MoveNodeCommand(m_profile, m_nodeIndex, oldRealPos, newRealPos));
    }
}

// 1ë²ˆ, 2ë²ˆ: ìš°í´ë¦­ ë©”ë‰´
void GraphNodeItem::contextMenuEvent(QGraphicsSceneContextMenuEvent *event) {
    if (!isSelected()) {
        event->ignore();
        return;
    }
    
    QMenu menu;
    QAction* deleteAction = menu.addAction("ë…¸ë“œ ì‚­ì œ");
    connect(deleteAction, &QAction::triggered, this, &GraphNodeItem::onDeleteTriggered);
    
    menu.exec(event->screenPos());
    event->accept(); // ë²„ê·¸ ìˆ˜ì •
}

// 2ë²ˆ: ì”¬ ì¢Œí‘œ (ì •ê·œí™”ë¨)
QVariant GraphNodeItem::itemChange(GraphicsItemChange change, const QVariant& value) {
    if (change == ItemPositionChange && scene()) {
        QPointF newScenePos = value.toPointF();

        if (m_view && m_view->isSnapEnabled()) {
            double gridSize = m_view->gridSize();
            if (gridSize > 0) {
                newScenePos.setX(qRound(newScenePos.x() / gridSize) * gridSize);
                // Yì¶• ìŠ¤ëƒ…ì€ ì •ê·œí™”ëœ ì”¬ ê·¸ë¦¬ë“œ ê¸°ì¤€ (ì”¬ 0~100 ì‚¬ì´ 10ì¹¸)
                double ySnapSize = (NORMALIZED_Y_MAX - NORMALIZED_Y_MIN) / 10.0;
                newScenePos.setY(qRound(newScenePos.y() / ySnapSize) * ySnapSize);
            }
        }
        
        newScenePos.setX(qMax(0.0, newScenePos.x()));

        // 2ë²ˆ: ì”¬ì˜ Yì¶• ë²”ìœ„(ì •ê·œí™”)ì— ë§ê²Œ ì œí•œ
        double clampedSceneY = qBound(NORMALIZED_Y_MIN, newScenePos.y(), NORMALIZED_Y_MAX);
        newScenePos.setY(clampedSceneY);
        
        return newScenePos;
    }
    return QGraphicsItem::itemChange(change, value);
}

void GraphNodeItem::onDeleteTriggered() {
    m_undoStack->push(new DeleteNodeCommand(m_profile, m_nodeIndex));
}

9. grapheditorview.h (ìˆ˜ì •ë¨)
#pragma once

#include <QGraphicsView>
#include <QMap>
#include <QList>
#include <qmath.h> // qFloor, qBound
#include <QGraphicsItem> // QGraphicsItem

class MotionDocument;
class MotorProfile;
class QUndoStack; 
class QKeyEvent; 

class GraphEditorView : public QGraphicsView {
    Q_OBJECT

public:
    explicit GraphEditorView(QWidget* parent = nullptr);
    void setDocument(MotionDocument* doc);
    
    void setUndoStack(QUndoStack* stack) { m_undoStack = stack; }
    
    bool isSnapEnabled() const { return m_snapToGrid; }
    double gridSize() const { return m_gridSizeX; } // Xì¶• ê·¸ë¦¬ë“œ í¬ê¸° ë°˜í™˜

public slots:
    void fitToView(); 
    void toggleSnapToGrid(bool checked) { m_snapToGrid = checked; }
    void fitToActiveMotor(MotorProfile* profile);

signals:
    void nodeSelectionChanged(QGraphicsItem* selectedNode);

protected:
    void wheelEvent(QWheelEvent* event) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void contextMenuEvent(QContextMenuEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override; 
    void drawBackground(QPainter* painter, const QRectF& rect) override;

private slots:
    void onDocumentCleared();
    void onMotorAdded(MotorProfile* profile);
    void onActiveMotorChanged(MotorProfile* active, MotorProfile* previous);
    void onProfileDataChanged();
    void onProfileConstraintsChanged();
    void updateConstraintItems(MotorProfile* profile);
    void onSceneSelectionChanged();

private:
    void rebuildProfileItems(MotorProfile* profile);
    void updateProfileVisibility(MotorProfile* profile, bool isActive);
    void clearAllProfileItems();

    QMap<MotorProfile*, QList<QGraphicsItem*>> m_constraintItems; 
    void setConstraintItemsVisible(MotorProfile* profile, bool visible);

    QUndoStack* m_undoStack = nullptr; 
    
    bool m_snapToGrid = false;
    // 3ë²ˆ: X, Y ê·¸ë¦¬ë“œ í¬ê¸° ë¶„ë¦¬
    double m_gridSizeX = 0.05; // 50ms (ì‹œê°„)
    double m_gridSizeY = 10.0; // ì •ê·œí™”ëœ Y (0~100)
    
    QGraphicsScene* m_scene;
    MotionDocument* m_document = nullptr;
    QMap<MotorProfile*, QList<QGraphicsItem*>> m_profileItems;
    bool m_isPanning = false;
    QPoint m_panStartPos;
};

10. grapheditorview.cpp (ìˆ˜ì •ë¨)
#include "grapheditorview.h"
#include "motionmodels.h"
#include "graphnodeitem.h"
#include "commands.h" // ì»¤ë§¨ë“œ
#include <QUndoStack> // Undo ìŠ¤íƒ
#include <QKeyEvent> // Delete í‚¤
#include <QWheelEvent>
#include <QMouseEvent>
#include <QContextMenuEvent>
#include <QMenu>
#include <QScrollBar>
#include <QGraphicsLineItem>
#include <QGraphicsTextItem> // ì¶• ê°’
#include <QPen>
#include <QBrush>
#include <QDebug>
#include <QTransform> // 1ë²ˆ: Yì¶• ë°˜ì „

GraphEditorView::GraphEditorView(QWidget* parent)
    : QGraphicsView(parent), m_scene(new QGraphicsScene(this)), m_isPanning(false)
{
    setScene(m_scene);
    setRenderHint(QPainter::Antialiasing); 
    setDragMode(QGraphicsView::NoDrag); 
    setTransformationAnchor(AnchorUnderMouse);
    setAlignment(Qt::AlignCenter); 
    m_scene->setSceneRect(-10000, -10000, 20000, 20000); 
    setFocusPolicy(Qt::StrongFocus); // Delete í‚¤
    
    scale(1, -1);
    
    connect(m_scene, &QGraphicsScene::selectionChanged, this, &GraphEditorView::onSceneSelectionChanged);
}

void GraphEditorView::setDocument(MotionDocument* doc) {
    if (m_document) {
        disconnect(m_document, nullptr, this, nullptr);
    }
    m_document = doc;
    if (!m_document) return;

    connect(m_document, &MotionDocument::documentCleared, this, &GraphEditorView::onDocumentCleared);
    connect(m_document, &MotionDocument::motorAdded, this, &GraphEditorView::onMotorAdded);
    connect(m_document, &MotionDocument::activeMotorChanged, this, &GraphEditorView::onActiveMotorChanged);
    // 3ë²ˆ: ëª¨í„° ë³€ê²½ ì‹œ Yì¶• ë ˆì´ë¸” ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•´ update() í˜¸ì¶œ
    connect(m_document, &MotionDocument::activeMotorChanged, this, QOverload<>::of(&GraphEditorView::update)); // backgroundDraw ì¬í˜¸ì¶œ

    for(MotorProfile* profile : m_document->motorProfiles()) {
        onMotorAdded(profile);
    }
    onActiveMotorChanged(m_document->activeProfile(), nullptr);
}

// --- ì´ë²¤íŠ¸ ì˜¤ë²„ë¼ì´ë“œ ---
// 4ë²ˆ: Xì¶•ë§Œ ì¤Œ
void GraphEditorView::wheelEvent(QWheelEvent* event) {
    double scaleFactor = (event->angleDelta().y() > 0) ? 1.15 : 1.0 / 1.15;
    scale(scaleFactor, 1.0); // Yì¶• ìŠ¤ì¼€ì¼ì€ 1.0ìœ¼ë¡œ ê³ ì •
}
void GraphEditorView::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::MiddleButton) {
        m_isPanning = true;
        m_panStartPos = event->pos();
        setCursor(Qt::ClosedHandCursor);
        event->accept();
        return;
    }
    QGraphicsView::mousePressEvent(event);
}
void GraphEditorView::mouseReleaseEvent(QMouseEvent* event) {
    if (event->button() == Qt::MiddleButton) {
        m_isPanning = false;
        setCursor(Qt::ArrowCursor);
        event->accept();
        return;
    }
    QGraphicsView::mouseReleaseEvent(event);
}
// 2ë²ˆ: ìˆ˜í‰ íŒ¨ë‹ ì œí•œ
void GraphEditorView::mouseMoveEvent(QMouseEvent* event) {
    if (m_isPanning) {
        // ìˆ˜í‰ ìŠ¤í¬ë¡¤ë°” ì¡°ì‘ ì½”ë“œ ì œê±°
        // horizontalScrollBar()->setValue(horizontalScrollBar()->value() - (event->pos().x() - m_panStartPos.x()));
        verticalScrollBar()->setValue(verticalScrollBar()->value() - (event->pos().y() - m_panStartPos.y()));
        m_panStartPos = event->pos(); 
        event->accept();
        return;
    }
    QGraphicsView::mouseMoveEvent(event);
}
void GraphEditorView::contextMenuEvent(QContextMenuEvent* event) {
    if (!m_document || !m_document->activeProfile() || !m_undoStack) return;
    QPointF scenePos = mapToScene(event->pos()); 
    MotorProfile* activeProfile = m_document->activeProfile();
    QMenu menu;
    QAction* addAction = menu.addAction("ì—¬ê¸°( " + 
        QString::number(scenePos.x(), 'f', 2) + ", " + 
        QString::number(activeProfile->getRealY(scenePos.y()), 'f', 2) + 
        " )ì— ìƒˆ ë…¸ë“œ ì¶”ê°€");
    if (scenePos.x() < 0) {
        addAction->setEnabled(false);
        addAction->setText(addAction->text() + " (X < 0 ë¶ˆê°€)");
    }
    else if (scenePos.y() < NORMALIZED_Y_MIN || scenePos.y() > NORMALIZED_Y_MAX) {
        addAction->setEnabled(false);
        addAction->setText(addAction->text() + " (Yì¶• ì œí•œ ìœ„ë°˜)");
    }
    connect(addAction, &QAction::triggered, this, [=]() {
        double realY = activeProfile->getRealY(scenePos.y());
        QPointF realPos(scenePos.x(), realY);
        m_undoStack->push(new AddNodeCommand(activeProfile, realPos));
    });
    menu.exec(event->globalPos());
}
void GraphEditorView::keyPressEvent(QKeyEvent* event) {
    if (event->key() == Qt::Key_Delete) {
        if (!m_document || !m_document->activeProfile() || !m_undoStack) return;
        QList<GraphNodeItem*> itemsToDelete;
        for (QGraphicsItem* item : m_scene->selectedItems()) {
            if (auto nodeItem = qgraphicsitem_cast<GraphNodeItem*>(item)) {
                itemsToDelete.append(nodeItem);
            }
        }
        if (itemsToDelete.isEmpty()) return;
        std::sort(itemsToDelete.begin(), itemsToDelete.end(), [](auto a, auto b) {
            return a->index() > b->index();
        });
        m_undoStack->beginMacro("ì„ íƒëœ ë…¸ë“œ ì‚­ì œ");
        for (GraphNodeItem* item : itemsToDelete) {
            m_undoStack->push(new DeleteNodeCommand(item->profile(), item->index()));
        }
        m_undoStack->endMacro();
        event->accept();
    } else {
        QGraphicsView::keyPressEvent(event);
    }
}

// 3ë²ˆ: Xì¶• ê°„ê²© ë° ë ˆì´ë¸” ì¡°ì •
void GraphEditorView::drawBackground(QPainter* painter, const QRectF& rect) {
    QGraphicsView::drawBackground(painter, rect);
    QPen gridPen(QColor(220, 220, 220), 0); 
    gridPen.setCosmetic(true);
    painter->setPen(gridPen);
    
    // 3ë²ˆ: Xì¶• ê·¸ë¦¬ë“œ (50ms)
    double left_x = qFloor(rect.left() / m_gridSizeX) * m_gridSizeX;
    for (double x = left_x; x < rect.right(); x += m_gridSizeX) {
        painter->drawLine(QPointF(x, rect.top()), QPointF(x, rect.bottom()));
    }
    // Yì¶• ê·¸ë¦¬ë“œ (ì”¬ ì¢Œí‘œ 10 ê°„ê²©)
    double top_y = qFloor(rect.top() / m_gridSizeY) * m_gridSizeY;
    for (double y = top_y; y < rect.bottom(); y += m_gridSizeY) {
        painter->drawLine(QPointF(rect.left(), y), QPointF(rect.right(), y));
    }
    
    // ì¶•ì„  (ë” êµµê²Œ)
    QPen axisPen(QColor(180, 180, 180), 0);
    axisPen.setCosmetic(true);
    painter->setPen(axisPen);
    painter->drawLine(QPointF(0, rect.top()), QPointF(0, rect.bottom())); // Yì¶•
    painter->drawLine(QPointF(rect.left(), 0), QPointF(rect.right(), 0)); // Xì¶•

    
    painter->save(); 
    painter->scale(1, -1); 

    painter->setPen(QPen(Qt::black));
    QFont font = painter->font();
    font.setPointSizeF(8); 
    painter->setFont(font);
    
    MotorProfile* activeProfile = m_document ? m_document->activeProfile() : nullptr;

    // 3ë²ˆ: Xì¶• ë ˆì´ë¸” (500ms ê°„ê²©)
    double xLabelInterval = m_gridSizeX * 10.0; // 0.5ì´ˆ
    double startXLabel = qFloor(rect.left() / xLabelInterval) * xLabelInterval;
    for (double x = startXLabel; x < rect.right(); x += xLabelInterval) {
        if (qAbs(x) > 1e-3 || qAbs(xLabelInterval - (qAbs(rect.left()) + qAbs(rect.right()))) < 1e-3) { // 0ì´ ì•„ë‹ˆê±°ë‚˜, 0ì´ í™”ë©´ì— ê±°ì˜ ê½‰ ì°° ë•Œ
             painter->drawText(QRectF(x - 50, 2, 100, 20), Qt::AlignHCenter | Qt::AlignTop, QString::number(x, 'f', 1)); // ì†Œìˆ˜ì  1ìë¦¬
        }
    }
    
    // Yì¶• ë ˆì´ë¸” (ì”¬ ì¢Œí‘œ 10 ê°„ê²©)
    double yLabelInterval = m_gridSizeY;
    double startYLabel = qFloor(rect.top() / yLabelInterval) * yLabelInterval;
    for (double y_scene = startYLabel; y_scene < rect.bottom(); y_scene += yLabelInterval) {
        if (qAbs(y_scene) > 1e-3 || qAbs(yLabelInterval - (qAbs(rect.top()) + qAbs(rect.bottom()))) < 1e-3) {
             QString label;
             if (activeProfile) {
                double y_real = activeProfile->getRealY(y_scene);
                label = QString::number(y_real, 'f', 1);
             } else {
                label = QString::number(y_scene); 
             }
             // Yì¶• ë°˜ì „ ë³´ì •: í…ìŠ¤íŠ¸ë¥¼ Xì¶• ë°”ë¡œ ì˜†ì— ê·¸ë¦¼ (Yì¢Œí‘œëŠ” ë°˜ì „ë¨)
             painter->drawText(QRectF(2, -y_scene - 10, 50, 20), Qt::AlignLeft | Qt::AlignVCenter, label);
        }
    }
    
    painter->restore(); 
}

// --- ìŠ¬ë¡¯ êµ¬í˜„ ---
void GraphEditorView::onDocumentCleared() {
    clearAllProfileItems();
    for(const auto& list : m_constraintItems) {
        qDeleteAll(list);
    }
    m_constraintItems.clear();
}
void GraphEditorView::clearAllProfileItems() {
    for(const auto& items : m_profileItems) {
        for(QGraphicsItem* item : items) {
            m_scene->removeItem(item);
            delete item;
        }
    }
}
void GraphEditorView::onMotorAdded(MotorProfile* profile) {
    if (!profile || m_profileItems.contains(profile)) return;
    m_profileItems.insert(profile, QList<QGraphicsItem*>());
    rebuildProfileItems(profile);
    updateProfileVisibility(profile, false); 
    connect(profile, &MotorProfile::dataChanged, this, &GraphEditorView::onProfileDataChanged);
    connect(profile, &MotorProfile::constraintsChanged, this, &GraphEditorView::onProfileConstraintsChanged);
}
void GraphEditorView::onActiveMotorChanged(MotorProfile* active, MotorProfile* previous) {
    if (previous) {
        updateProfileVisibility(previous, false);
        setConstraintItemsVisible(previous, false); 
    }
    if (active) {
        updateProfileVisibility(active, true);
        updateConstraintItems(active); 
        setConstraintItemsVisible(active, true);  
    }
}
void GraphEditorView::onProfileDataChanged() {
    MotorProfile* profile = qobject_cast<MotorProfile*>(sender());
    if (profile) {
        int selectedIndex = -1;
        QPointF selectedRealPos; // ì‹¤ì œ ì¢Œí‘œ ì €ì¥
        if (m_scene->selectedItems().size() == 1) {
            if (auto node = qgraphicsitem_cast<GraphNodeItem*>(m_scene->selectedItems().first())) {
                selectedIndex = node->index();
                selectedRealPos = node->profile()->nodeAt(selectedIndex); // ì‚­ì œ/ì´ë™ ì „ ì‹¤ì œ ì¢Œí‘œ
            }
        }

        rebuildProfileItems(profile);
        updateProfileVisibility(profile, (profile == m_document->activeProfile()));

        if (selectedIndex != -1) {
            GraphNodeItem* reselectedNode = nullptr;
            // ì¸ë±ìŠ¤ê°€ ì•„ë‹Œ ì‹¤ì œ ì¢Œí‘œì™€ ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œë¥¼ ë‹¤ì‹œ ì„ íƒ (ì •ë ¬/ì‚­ì œ ëŒ€ì‘)
            qreal minDistSq = -1.0;
            for (auto item : m_profileItems.value(profile)) {
                if (auto node = qgraphicsitem_cast<GraphNodeItem*>(item)) {
                     QPointF currentRealPos = node->profile()->nodeAt(node->index());
                     qreal distSq = QPointF(currentRealPos - selectedRealPos).manhattanLength(); // L1 ê±°ë¦¬ (ë¹ ë¦„)
                     if (reselectedNode == nullptr || distSq < minDistSq) {
                         minDistSq = distSq;
                         reselectedNode = node;
                     }
                }
            }
            if (reselectedNode && minDistSq < 1e-3) { // ë§¤ìš° ê°€ê¹Œìš°ë©´ ì„ íƒ ë³µì›
                 reselectedNode->setSelected(true);
            } else {
                 reselectedNode = nullptr; // ëª» ì°¾ìœ¼ë©´ ì„ íƒ í•´ì œ
            }
            emit nodeSelectionChanged(reselectedNode); // MainWindow ì—…ë°ì´íŠ¸
        }
    }
}
void GraphEditorView::onProfileConstraintsChanged() {
    MotorProfile* profile = qobject_cast<MotorProfile*>(sender());
     if (profile) {
        updateConstraintItems(profile);
     }
}
void GraphEditorView::rebuildProfileItems(MotorProfile* profile) {
    if (!profile) return;
    if (m_profileItems.contains(profile)) {
        for (QGraphicsItem* item : m_profileItems.value(profile)) {
            m_scene->removeItem(item);
            delete item;
        }
        m_profileItems[profile].clear();
    }
    QList<QGraphicsItem*>& items = m_profileItems[profile];
    const auto& nodes = profile->nodes(); // "ì‹¤ì œ" ì¢Œí‘œ ë…¸ë“œ
    QColor color = profile->color();
    QPen linePen(color, 2); 
    for (int i = 0; i < nodes.size() - 1; ++i) {
        double sceneY_i = profile->getNormalizedY(nodes[i].y());
        double sceneY_i1 = profile->getNormalizedY(nodes[i+1].y());
        QGraphicsLineItem* line = m_scene->addLine(QLineF(nodes[i].x(), sceneY_i, nodes[i+1].x(), sceneY_i1), linePen);
        items.append(line);
    }
    for (int i = 0; i < nodes.size(); ++i) {
        GraphNodeItem* nodeItem = new GraphNodeItem(profile, i, this, m_undoStack);
        m_scene->addItem(nodeItem);
        items.append(nodeItem);
    }
}
void GraphEditorView::updateProfileVisibility(MotorProfile* profile, bool isActive) {
    if (!profile || !m_profileItems.contains(profile)) return;
    QList<QGraphicsItem*>& items = m_profileItems[profile];
    QColor color = profile->color();
    qreal opacity;
    int zValue;
    if (isActive) {
        opacity = 1.0;
        zValue = 1; 
    } else {
        color.setAlpha(60); 
        opacity = 0.5;
        zValue = 0; 
    }
    for (QGraphicsItem* item : items) {
        item->setZValue(zValue);
        item->setOpacity(opacity);
        item->setEnabled(isActive); 
        if (auto line = qgraphicsitem_cast<QGraphicsLineItem*>(item)) {
            QPen pen = line->pen();
            pen.setColor(color);
            line->setPen(pen);
        } else if (auto node = qgraphicsitem_cast<GraphNodeItem*>(item)) {
            node->setBrush(QBrush(color));
            node->setPen(QPen(isActive ? Qt::black : color.darker(120), 1));
        }
    }
}

// 3ë²ˆ: ì¶• ê°’ (ìƒ/í•˜í•œì„ ) ìƒ‰ìƒ ë³€ê²½
void GraphEditorView::updateConstraintItems(MotorProfile* profile) {
    if (!profile) return;

    if (m_constraintItems.contains(profile)) {
        qDeleteAll(m_constraintItems.value(profile));
        m_constraintItems[profile].clear();
    } else {
        m_constraintItems.insert(profile, QList<QGraphicsItem*>());
    }

    QList<QGraphicsItem*>& items = m_constraintItems[profile];
    QRectF r = sceneRect(); 
    
    double sceneYMin = NORMALIZED_Y_MIN; // 2ë²ˆ: ì •ê·œí™”ëœ ì¢Œí‘œ ì‚¬ìš©
    double sceneYMax = NORMALIZED_Y_MAX; // 2ë²ˆ: ì •ê·œí™”ëœ ì¢Œí‘œ ì‚¬ìš©
    
    QColor lineColor(128, 128, 128, 150); 
    QColor textColor(80, 80, 80); 

    QPen linePen(lineColor, 3, Qt::SolidLine); 

    QGraphicsLineItem* minLine = m_scene->addLine(r.left(), sceneYMin, r.right(), sceneYMin, linePen);
    QGraphicsLineItem* maxLine = m_scene->addLine(r.left(), sceneYMax, r.right(), sceneYMax, linePen);
    minLine->setZValue(-1); 
    maxLine->setZValue(-1);
    items.append(minLine);
    items.append(maxLine);

    QGraphicsTextItem* minLabel = m_scene->addText(QString::number(profile->yMin(), 'f', 1));
    minLabel->setTransform(QTransform::fromScale(1, -1)); 
    minLabel->setPos(r.left() + 5, sceneYMin + minLabel->boundingRect().height()); 
    minLabel->setDefaultTextColor(textColor); 
    minLabel->setZValue(-1);
    items.append(minLabel);

    QGraphicsTextItem* maxLabel = m_scene->addText(QString::number(profile->yMax(), 'f', 1));
    maxLabel->setTransform(QTransform::fromScale(1, -1)); 
    maxLabel->setPos(r.left() + 5, sceneYMax); 
    maxLabel->setDefaultTextColor(textColor); 
    maxLabel->setZValue(-1);
    items.append(maxLabel);

    setConstraintItemsVisible(profile, (profile == m_document->activeProfile()));
}
void GraphEditorView::setConstraintItemsVisible(MotorProfile* profile, bool visible) {
    if (!m_constraintItems.contains(profile)) return;
    for (QGraphicsItem* item : m_constraintItems.value(profile)) {
        item->setVisible(visible);
    }
}

// 3c. Fit to View ìŠ¬ë¡¯
void GraphEditorView::fitToView() {
    QRectF bounds;
    if (m_document && m_document->activeProfile()) {
         // í˜„ì¬ í™œì„± ëª¨í„° ê¸°ì¤€ìœ¼ë¡œ fit
         bounds = QRectF(QPointF(0, NORMALIZED_Y_MAX), QPointF(100, NORMALIZED_Y_MIN)); // ê¸°ë³¸ ë²”ìœ„
         if(!m_document->activeProfile()->nodes().isEmpty()){
            double xMax = 0;
            for(const auto& node : m_document->activeProfile()->nodes()){
                if(node.x() > xMax) xMax = node.x();
            }
             if(xMax < 10.0) xMax = 10.0;
             bounds.setRight(xMax);
         }
    } else if (!m_scene->items().isEmpty()) {
        bounds = m_scene->itemsBoundingRect(); // ëª¨ë“  ì•„ì´í…œ ê¸°ì¤€ (ëª¨í„° ì—†ì„ ë•Œ)
    } else {
        bounds = QRectF(-100, 100, 200, -200); // ì™„ì „ ë¹ˆ ê²½ìš°
    }

    if (bounds.isValid()) {
        if (bounds.top() < NORMALIZED_Y_MIN) bounds.setTop(NORMALIZED_Y_MIN); // Y ìƒë‹¨ (0ë³´ë‹¤ ì‘ìœ¼ë©´ 0) - Yì¶• ë°˜ì „ ê³ ë ¤
        if (bounds.bottom() > NORMALIZED_Y_MAX) bounds.setBottom(NORMALIZED_Y_MAX); // Y í•˜ë‹¨ (100ë³´ë‹¤ í¬ë©´ 100) - Yì¶• ë°˜ì „ ê³ ë ¤
        if (bounds.left() < 0.0) bounds.setLeft(0.0); // X ì¢Œì¸¡
        
        double yMargin = qAbs(bounds.height()) * 0.1;
        double xMargin = qAbs(bounds.width()) * 0.1;
        fitInView(bounds.marginsAdded(QMarginsF(xMargin, yMargin, xMargin, yMargin)), Qt::KeepAspectRatio);
        centerOn(bounds.center().x(), bounds.center().y()); // 2ë²ˆ: ì¤‘ì•™ ì •ë ¬
    }
}

// 2ë²ˆ: ë·° ì¡°ì ˆ (ì •ê·œí™”ëœ Yì¶• ê¸°ì¤€)
void GraphEditorView::fitToActiveMotor(MotorProfile* profile)
{
    if (!profile) {
        fitToView();
        return;
    }

    double sceneYMin = NORMALIZED_Y_MIN;
    double sceneYMax = NORMALIZED_Y_MAX;
    double xMin = 0.0; 
    double xMax = 100.0; 

    if (!profile->nodes().isEmpty()) {
        for (const auto& node : profile->nodes()) {
            if (node.x() > xMax) xMax = node.x();
        }
    }
    if (xMax < 10.0) xMax = 10.0; 

    QRectF motorBounds(QPointF(xMin, sceneYMax), QPointF(xMax, sceneYMin));

    double yMargin = qAbs(sceneYMax - sceneYMin) * 0.1; // 10
    double xMargin = qAbs(xMax - xMin) * 0.1;
    if (xMargin < 20) xMargin = 20;

    fitInView(motorBounds.marginsAdded(QMarginsF(xMargin, yMargin, xMargin, yMargin)), Qt::KeepAspectRatio);
    // 2ë²ˆ: X=0 ì¤‘ì•™ ì •ë ¬ (YëŠ” ì´ë¯¸ ì •ê·œí™” ë²”ìœ„ ì¤‘ì•™)
    centerOn(0, (sceneYMax + sceneYMin) / 2.0 );
}

void GraphEditorView::onSceneSelectionChanged()
{
    auto selected = m_scene->selectedItems();
    if (selected.size() == 1) {
        if (auto node = qgraphicsitem_cast<GraphNodeItem*>(selected.first())) {
            emit nodeSelectionChanged(node);
            return;
        }
    }
    emit nodeSelectionChanged(nullptr); 
}

11. mainwindow.h (ë³€ê²½ ì—†ìŒ)
#pragma once

#include <QMainWindow>
#include <QGraphicsItem> // 1ë²ˆ: QGraphicsItem

// Qt 5.7 ë¯¸ë§Œì¸ ê²½ìš° QOverload ëŒ€ì‹  static_cast ì‚¬ìš©
#if QT_VERSION < QT_VERSION_CHECK(5, 7, 0)
// static_castë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ ë³„ë„ í—¤ë” í•„ìš” ì—†ìŒ
#else
#include <QOverload> 
#endif

// ì „ë°© ì„ ì–¸
class MotionDocument;
class GraphEditorView;
class MotorProfile;
class GraphNodeItem; // 1ë²ˆ: GraphNodeItem
class QTreeWidget;
class QTreeWidgetItem;
class QDoubleSpinBox;
class QToolButton; 
class QPushButton; 
class QUndoStack; 
class QAction;
class QGroupBox; // 1ë²ˆ: QGroupBox

class MainWindow : public QMainWindow {
    Q_OBJECT

public:
    MainWindow(QWidget* parent = nullptr);
    ~MainWindow();

private slots:
    void onMotorSelectionChanged(QTreeWidgetItem* current, QTreeWidgetItem* previous);
    void onAddMotor();
    void onRemoveMotor();
    void onSaveDocument();
    void onLoadDocument();
    void onExportDocument(); 
    void onFitToView();      
    void onApplyConstraints();
    void onDocumentModelChanged();
    void onActiveMotorSwitched(MotorProfile* active, MotorProfile* previous);

    // 1ë²ˆ: ë…¸ë“œ ì¢Œí‘œ í¸ì§‘ ìŠ¬ë¡¯
    void onNodeSelected(QGraphicsItem* selectedNode);
    void onApplyNodeCoords();

private:
    void createActions();
    void createMenus();
    void createDocks();
    
    void connectProfileToSpinBoxes(MotorProfile* profile);
    void disconnectProfileFromSpinBoxes(MotorProfile* profile);

    MotionDocument* m_document;
    GraphEditorView* m_view;

    QUndoStack* m_undoStack; 
    
    QTreeWidget* m_motorTreeWidget;
    QTreeWidgetItem* m_motorsRootItem; 
    QToolButton* m_addMotorButton;
    QToolButton* m_removeMotorButton;

    QDoubleSpinBox* m_yMinSpin;
    QDoubleSpinBox* m_yMaxSpin;
    QDoubleSpinBox* m_slopeSpin;
    QPushButton* m_applyConstraintsButton;
    
    // 1ë²ˆ: ë…¸ë“œ í¸ì§‘ ìœ„ì ¯
    QGroupBox* m_nodeEditGroup;
    QDoubleSpinBox* m_nodeXSpin;
    QDoubleSpinBox* m_nodeYSpin;
    QPushButton* m_applyNodeCoordsButton;
    GraphNodeItem* m_selectedNode = nullptr; // í˜„ì¬ ì„ íƒëœ ë…¸ë“œ ì €ì¥
    
    QAction* m_saveAction;
    QAction* m_loadAction;
    QAction* m_exportAction; 
    QAction* m_undoAction;   
    QAction* m_redoAction;   
    QAction* m_fitToViewAction; 
    QAction* m_snapGridAction;  
};

12. mainwindow.cpp (ìˆ˜ì •ë¨)
#include "mainwindow.h"
#include "motionmodels.h"
#include "grapheditorview.h"
#include "graphnodeitem.h" // 1ë²ˆ: GraphNodeItem
#include "commands.h" // 1ë²ˆ: MoveNodeCommand

#include <QMenu>
#include <QMenuBar>
#include <QDockWidget>
#include <QTreeWidget>
#include <QTreeWidgetItem>
#include <QHeaderView>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QToolButton>
#include <QPushButton>
#include <QFormLayout>
#include <QDoubleSpinBox>
#include <QSpinBox> // Export
#include <QRadioButton> // Export
#include <QDialogButtonBox> // Export
#include <QFileDialog>
#include <QInputDialog>
#include <QMessageBox>
#include <QStatusBar>
#include <QUndoStack> // Undo ìŠ¤íƒ
#include <QDebug> // qrand
#include <QTime> // qsrand
#include <QJsonArray> // 4ë²ˆ
#include <QJsonObject> // 4ë²ˆ
#include <QJsonDocument> // 4ë²ˆ
#include <QGroupBox> // 1ë²ˆ

MainWindow::MainWindow(QWidget* parent)
    : QMainWindow(parent)
{
    m_undoStack = new QUndoStack(this);
    m_document = new MotionDocument(this);
    m_view = new GraphEditorView(this);
    m_view->setDocument(m_document);
    m_view->setUndoStack(m_undoStack); 
    setCentralWidget(m_view); 

    createActions();
    createMenus();
    createDocks(); 
    
    connect(m_motorTreeWidget, &QTreeWidget::currentItemChanged, 
            this, &MainWindow::onMotorSelectionChanged);
    connect(m_document, &MotionDocument::modelChanged, 
            this, &MainWindow::onDocumentModelChanged);
    connect(m_document, &MotionDocument::activeMotorChanged, 
            this, &MainWindow::onActiveMotorSwitched);
    connect(m_fitToViewAction, &QAction::triggered, m_view, &GraphEditorView::fitToView);
    connect(m_snapGridAction, &QAction::toggled, m_view, &GraphEditorView::toggleSnapToGrid);
    
    // 1ë²ˆ: ë·°ì—ì„œ ë…¸ë“œ ì„ íƒ ì‹œê·¸ë„ ì—°ê²°
    connect(m_view, &GraphEditorView::nodeSelectionChanged, this, &MainWindow::onNodeSelected);
            
    qsrand(QTime::currentTime().msec()); 
    MotorProfile* m1 = m_document->addMotor("Motor 1 (Red)", Qt::red);
    m1->internalAddNode(QPointF(0, 0));
    m1->internalAddNode(QPointF(200, 50));
    MotorProfile* m2 = m_document->addMotor("Motor 4 (Blue)", Qt::blue);
    m2->internalAddNode(QPointF(50, -30));
    m2->internalAddNode(QPointF(150, 80));

    onDocumentModelChanged(); 
    
    if (m_motorsRootItem->childCount() > 0) {
        m_motorsRootItem->child(0)->setSelected(true);
    }

    m_undoStack->clear(); 
    setMinimumSize(800, 600);
    setWindowTitle("Profile Orchestrator (Qt 5)"); 
}

MainWindow::~MainWindow() {}

void MainWindow::createActions() {
    m_saveAction = new QAction("ì €ì¥ (&S)", this);
    m_saveAction->setShortcut(QKeySequence::Save);
    connect(m_saveAction, &QAction::triggered, this, &MainWindow::onSaveDocument);

    m_loadAction = new QAction("ë¶ˆëŸ¬ì˜¤ê¸° (&O)", this);
    m_loadAction->setShortcut(QKeySequence::Open);
    connect(m_loadAction, &QAction::triggered, this, &MainWindow::onLoadDocument);

    m_exportAction = new QAction("ë‚´ë³´ë‚´ê¸° (&E)...", this);
    connect(m_exportAction, &QAction::triggered, this, &MainWindow::onExportDocument);

    m_undoAction = m_undoStack->createUndoAction(this, "ì‹¤í–‰ ì·¨ì†Œ (&U)");
    m_undoAction->setShortcut(QKeySequence::Undo);
    m_redoAction = m_undoStack->createRedoAction(this, "ë‹¤ì‹œ ì‹¤í–‰ (&R)");
    m_redoAction->setShortcut(QKeySequence::Redo);

    m_fitToViewAction = new QAction("ì „ì²´ ë³´ê¸° (&F)", this);
    m_fitToViewAction->setShortcut(Qt::Key_F);
    
    m_snapGridAction = new QAction("ê·¸ë¦¬ë“œì— ë§ì¶”ê¸° (&G)", this);
    m_snapGridAction->setCheckable(true);
    m_snapGridAction->setShortcut(Qt::Key_G);
}

void MainWindow::createMenus() {
    QMenu* fileMenu = menuBar()->addMenu("íŒŒì¼ (&F)");
    fileMenu->addAction(m_loadAction);
    fileMenu->addAction(m_saveAction);
    fileMenu->addAction(m_exportAction);
    
    QMenu* editMenu = menuBar()->addMenu("í¸ì§‘ (&E)");
    editMenu->addAction(m_undoAction);
    editMenu->addAction(m_redoAction);
    editMenu->addSeparator();
    editMenu->addAction(m_snapGridAction);
    
    QMenu* viewMenu = menuBar()->addMenu("ë³´ê¸° (&V)");
    viewMenu->addAction(m_fitToViewAction);
}

void MainWindow::createDocks() {
    // 8. ì¢Œì¸¡ ëª¨í„° ì„ íƒì°½
    QDockWidget* leftDock = new QDockWidget("Object", this);
    QWidget* motorListWidget = new QWidget; 
    QVBoxLayout* motorLayout = new QVBoxLayout(motorListWidget);
    motorLayout->setContentsMargins(0,0,0,0);
    motorLayout->setSpacing(0);
    m_motorTreeWidget = new QTreeWidget;
    m_motorTreeWidget->setHeaderHidden(true); 
    m_motorsRootItem = new QTreeWidgetItem(m_motorTreeWidget, {"Motors"});
    m_motorsRootItem->setFlags(m_motorsRootItem->flags() & ~Qt::ItemIsSelectable);
    m_motorsRootItem->setExpanded(true);
    motorLayout->addWidget(m_motorTreeWidget); 
    QHBoxLayout* buttonLayout = new QHBoxLayout;
    m_addMotorButton = new QToolButton();
    m_addMotorButton->setText("+");
    m_removeMotorButton = new QToolButton();
    m_removeMotorButton->setText("-");
    buttonLayout->addStretch();
    buttonLayout->addWidget(m_addMotorButton);
    buttonLayout->addWidget(m_removeMotorButton);
    motorLayout->addLayout(buttonLayout); 
    leftDock->setWidget(motorListWidget); 
    addDockWidget(Qt::LeftDockWidgetArea, leftDock);
    connect(m_addMotorButton, &QToolButton::clicked, this, &MainWindow::onAddMotor);
    connect(m_removeMotorButton, &QToolButton::clicked, this, &MainWindow::onRemoveMotor);

    // 7. ìš°ì¸¡ ì œì•½ ì¡°ê±´ ë©”ë‰´
    QDockWidget* rightDock = new QDockWidget("ì†ì„±", this);
    QWidget* constraintsWidget = new QWidget;
    QVBoxLayout* rightLayout = new QVBoxLayout(constraintsWidget);
    
    // --- ì œì•½ ì¡°ê±´ ê·¸ë£¹ ---
    QGroupBox* constraintsGroup = new QGroupBox("ëª¨í„° ì œì•½ ì¡°ê±´");
    QFormLayout* formLayout = new QFormLayout; 
    m_yMinSpin = new QDoubleSpinBox;
    m_yMinSpin->setRange(-100000, 100000); // ë²”ìœ„ í™•ì¥
    formLayout->addRow("Y ìµœì†Œê°’:", m_yMinSpin);
    m_yMaxSpin = new QDoubleSpinBox;
    m_yMaxSpin->setRange(-100000, 100000); // ë²”ìœ„ í™•ì¥
    formLayout->addRow("Y ìµœëŒ€ê°’:", m_yMaxSpin);
    m_slopeSpin = new QDoubleSpinBox;
    m_slopeSpin->setRange(0, 100000);
    m_slopeSpin->setValue(1000.0); 
    formLayout->addRow("ìµœëŒ€ ê¸°ìš¸ê¸°:", m_slopeSpin);
    m_applyConstraintsButton = new QPushButton("ì œì•½ì¡°ê±´ ì ìš©");
    formLayout->addWidget(m_applyConstraintsButton);
    constraintsGroup->setLayout(formLayout);
    rightLayout->addWidget(constraintsGroup); 

    // 1ë²ˆ: --- ë…¸ë“œ ì¢Œí‘œ í¸ì§‘ ê·¸ë£¹ ---
    m_nodeEditGroup = new QGroupBox("ì„ íƒëœ ë…¸ë“œ ì¢Œí‘œ");
    QFormLayout* nodeEditLayout = new QFormLayout;
    m_nodeXSpin = new QDoubleSpinBox;
    m_nodeXSpin->setRange(0.0, 100000.0); // X(ì‹œê°„)ëŠ” 0 ì´ìƒ
    m_nodeXSpin->setDecimals(3);
    m_nodeYSpin = new QDoubleSpinBox; 
    m_nodeYSpin->setRange(-100000.0, 100000.0); // Y ë²”ìœ„ëŠ” onNodeSelectedì—ì„œ ì„¤ì •
    m_nodeYSpin->setDecimals(3);
    m_applyNodeCoordsButton = new QPushButton("ì¢Œí‘œ ì ìš©");
    nodeEditLayout->addRow("Time (X):", m_nodeXSpin);
    nodeEditLayout->addRow("Value (Y):", m_nodeYSpin);
    nodeEditLayout->addWidget(m_applyNodeCoordsButton);
    m_nodeEditGroup->setLayout(nodeEditLayout);
    rightLayout->addWidget(m_nodeEditGroup);
    m_nodeEditGroup->setEnabled(false); // ì‹œì‘ ì‹œ ë¹„í™œì„±í™”
    
    rightLayout->addStretch(); // ìœ„ì ¯ë“¤ì´ ìƒë‹¨ì— ì •ë ¬ë˜ë„ë¡
    
    rightDock->setWidget(constraintsWidget);
    addDockWidget(Qt::RightDockWidgetArea, rightDock);

    connect(m_applyConstraintsButton, &QPushButton::clicked, this, &MainWindow::onApplyConstraints);
    connect(m_applyNodeCoordsButton, &QPushButton::clicked, this, &MainWindow::onApplyNodeCoords); // 1ë²ˆ
}

void MainWindow::onMotorSelectionChanged(QTreeWidgetItem* current, QTreeWidgetItem* previous) {
    Q_UNUSED(previous); 
    if (!current || current == m_motorsRootItem) {
        m_document->setActiveMotor(nullptr);
        return;
    }
    MotorProfile* profile = current->data(0, Qt::UserRole).value<MotorProfile*>();
    m_document->setActiveMotor(profile);
}

void MainWindow::onAddMotor() {
    bool ok;
    QString name = QInputDialog::getText(this, "ìƒˆ ëª¨í„°", "ëª¨í„° ì´ë¦„:", QLineEdit::Normal, "New Motor", &ok);
    if (ok && !name.isEmpty()) {
        QColor color = QColor::fromHsv(qrand() % 360, 200, 200);
        m_document->addMotor(name, color);
    }
}

void MainWindow::onRemoveMotor() {
    QTreeWidgetItem* currentItem = m_motorTreeWidget->currentItem();
    if (!currentItem || currentItem == m_motorsRootItem) return;
    MotorProfile* profile = currentItem->data(0, Qt::UserRole).value<MotorProfile*>();
    if (!profile) return;
    auto reply = QMessageBox::question(this, "ëª¨í„° ì‚­ì œ",
        QString("'%1' ëª¨í„°ë¥¼ ì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?").arg(profile->name()),
        QMessageBox::Yes | QMessageBox::No);
    if (reply == QMessageBox::Yes) {
        m_document->removeMotor(profile);
    }
}

void MainWindow::onSaveDocument() {
    QString fileName = QFileDialog::getSaveFileName(this, "í”„ë¡œíŒŒì¼ ì €ì¥", "", "ëª¨ì…˜ JSON íŒŒì¼ (*.json)");
    if (fileName.isEmpty()) return;
    if (!m_document->saveToFile(fileName)) {
        QMessageBox::warning(this, "ì €ì¥ ì‹¤íŒ¨", "íŒŒì¼ì„ ì €ì¥í•˜ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    }
}

void MainWindow::onLoadDocument() {
    QString fileName = QFileDialog::getOpenFileName(this, "í”„ë¡œíŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°", "", "ëª¨ì…˜ JSON íŒŒì¼ (*.json)");
    if (fileName.isEmpty()) return;
    if (!m_document->loadFromFile(fileName)) {
        QMessageBox::warning(this, "ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨", "íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
    }
}

void MainWindow::onFitToView() {
    m_view->fitToView();
}

void MainWindow::onApplyConstraints() {
    MotorProfile* profile = m_document->activeProfile();
    if (profile) {
        profile->checkAllNodes();
    }
}

void MainWindow::onDocumentModelChanged() {
    m_motorTreeWidget->blockSignals(true); 
    m_motorsRootItem->takeChildren(); 
    QTreeWidgetItem* activeItem = nullptr;
    MotorProfile* activeProfile = m_document->activeProfile();
    for (MotorProfile* profile : m_document->motorProfiles()) {
        QTreeWidgetItem* item = new QTreeWidgetItem(m_motorsRootItem);
        item->setText(0, profile->name());
        item->setForeground(0, profile->color());
        item->setData(0, Qt::UserRole, QVariant::fromValue(profile));
        if (profile == activeProfile) {
            activeItem = item;
        }
    }
    if (activeItem) {
        m_motorTreeWidget->setCurrentItem(activeItem);
    } else if (m_motorsRootItem->childCount() > 0) {
        m_motorTreeWidget->setCurrentItem(m_motorsRootItem->child(0));
    }
    m_motorTreeWidget->blockSignals(false);
    
    onActiveMotorSwitched(m_document->activeProfile(), nullptr); 
    onNodeSelected(nullptr); // 1ë²ˆ: ëª¨ë¸ ë³€ê²½ ì‹œ ì„ íƒ íŒ¨ë„ í´ë¦¬ì–´
    m_undoStack->clear(); 
}

// 2ë²ˆ: ë·° ë³€ê²½(fit) ì½”ë“œ ë³µì›
void MainWindow::onActiveMotorSwitched(MotorProfile* active, MotorProfile* previous) {
    if (previous) {
        disconnectProfileFromSpinBoxes(previous);
    }
    if (active) {
        connectProfileToSpinBoxes(active);

        m_motorTreeWidget->blockSignals(true);
        for(int i=0; i < m_motorsRootItem->childCount(); ++i) {
            QTreeWidgetItem* item = m_motorsRootItem->child(i);
            MotorProfile* profile = item->data(0, Qt::UserRole).value<MotorProfile*>();
            if(profile == active) {
                m_motorTreeWidget->setCurrentItem(item);
                break;
            }
        }
        m_motorTreeWidget->blockSignals(false);
        
        // 2ë²ˆ: ì‹œì  ë³€ê²½ ì½”ë“œ ë³µì› (ì´ì œ Yì¶•ì€ ê³ ì •ë˜ê³  Xì¶•ë§Œ ì¡°ì ˆë¨)
        m_view->fitToActiveMotor(active);
        
    } else {
        // 2ë²ˆ: ì‹œì  ë³€ê²½ ì½”ë“œ ë³µì›
        m_view->fitToActiveMotor(nullptr);
    }
    
    onNodeSelected(nullptr); // 1ë²ˆ: ëª¨í„° ë³€ê²½ ì‹œ ì„ íƒ íŒ¨ë„ í´ë¦¬ì–´
    m_undoStack->clear(); 
}

// 7. ìŠ¤í•€ë°•ìŠ¤ <-> ëª¨ë¸ ì—°ê²° (static_castë¡œ í†µì¼)
void MainWindow::connectProfileToSpinBoxes(MotorProfile* profile) {
    if (!profile) return;
    
    m_yMinSpin->setValue(profile->yMin());
    m_yMaxSpin->setValue(profile->yMax());
    m_slopeSpin->setValue(profile->maxSlope());

#if QT_VERSION < QT_VERSION_CHECK(5, 7, 0)
    connect(m_yMinSpin, static_cast<void (QDoubleSpinBox::*)(double)>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setYMin);
    connect(m_yMaxSpin, static_cast<void (QDoubleSpinBox::*)(double)>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setYMax);
    connect(m_slopeSpin, static_cast<void (QDoubleSpinBox::*)(double)>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setMaxSlope);
#else
    connect(m_yMinSpin, qOverload<double>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setYMin);
    connect(m_yMaxSpin, qOverload<double>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setYMax);
    connect(m_slopeSpin, qOverload<double>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setMaxSlope);
#endif
}

// 7. ìŠ¤í•€ë°•ìŠ¤ <-> ëª¨ë¸ ì—°ê²° í•´ì œ (static_castë¡œ í†µì¼)
void MainWindow::disconnectProfileFromSpinBoxes(MotorProfile* profile) {
     if (!profile) return;
#if QT_VERSION < QT_VERSION_CHECK(5, 7, 0)
     disconnect(m_yMinSpin, static_cast<void (QDoubleSpinBox::*)(double)>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setYMin);
     disconnect(m_yMaxSpin, static_cast<void (QDoubleSpinBox::*)(double)>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setYMax);
     disconnect(m_slopeSpin, static_cast<void (QDoubleSpinBox::*)(double)>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setMaxSlope);
#else
     disconnect(m_yMinSpin, qOverload<double>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setYMin);
     disconnect(m_yMaxSpin, qOverload<double>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setYMax);
     disconnect(m_slopeSpin, qOverload<double>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setMaxSlope);
#endif
}


// --- 5. Export ë‹¤ì´ì–¼ë¡œê·¸ ë¡œì§ (ìƒ˜í”Œë§ ì‹œ ëª¨ë“  ëª¨í„° í¬í•¨) ---
void MainWindow::onExportDocument() {
    if (!m_document) return; // í™œì„± ëª¨í„°ê°€ ì—†ì–´ë„ ë‚´ë³´ë‚´ê¸° ê°€ëŠ¥

    // 1. ë‹¤ì´ì–¼ë¡œê·¸ ìƒì„±
    QDialog dialog(this);
    dialog.setWindowTitle("í”„ë¡œíŒŒì¼ ë‚´ë³´ë‚´ê¸°");
    QVBoxLayout layout(&dialog);
    QRadioButton* nodesOnlyRadio = new QRadioButton("í™œì„± ëª¨í„° ë…¸ë“œë§Œ ë‚´ë³´ë‚´ê¸°");
    QRadioButton* sampledRadio = new QRadioButton("ëª¨ë“  ëª¨í„° ìƒ˜í”Œë§í•˜ì—¬ ë‚´ë³´ë‚´ê¸°"); // 5ë²ˆ: "ëª¨ë“  ëª¨í„°"
    QRadioButton* allNodesRadio = new QRadioButton("ëª¨ë“  ëª¨í„°ì˜ ë…¸ë“œ ë‚´ë³´ë‚´ê¸° (Saveì™€ ë™ì¼)");
    
    nodesOnlyRadio->setChecked(true);
    layout.addWidget(nodesOnlyRadio);
    layout.addWidget(sampledRadio);
    layout.addWidget(allNodesRadio);

    // ìƒ˜í”Œë§ ì˜µì…˜ìš© ìœ„ì ¯
    QWidget* optionsWidget = new QWidget;
    QFormLayout* optionsLayout = new QFormLayout(optionsWidget);
    QDoubleSpinBox* endTimeSpin = new QDoubleSpinBox;
    endTimeSpin->setRange(0.0, 10000.0); 
    endTimeSpin->setValue(2.0); 
    // ê°€ì¥ ê¸´ ëª¨ì…˜ ì‹œê°„ìœ¼ë¡œ ê¸°ë³¸ê°’ ì„¤ì •
    double maxTime = 0.0;
    for (MotorProfile* p : m_document->motorProfiles()) {
        if (!p->nodes().isEmpty() && p->nodes().last().x() > maxTime) {
            maxTime = p->nodes().last().x();
        }
    }
    if (maxTime < 2.0) maxTime = 2.0;
    endTimeSpin->setValue(maxTime);
    endTimeSpin->setSuffix(" s");
    QSpinBox* hzSpin = new QSpinBox;
    hzSpin->setRange(1, 10000);
    hzSpin->setValue(100);
    hzSpin->setSuffix(" Hz");
    optionsLayout->addRow("ì¢…ë£Œ ì‹œê°„:", endTimeSpin);
    optionsLayout->addRow("ìƒ˜í”Œë§ ì†ë„:", hzSpin);
    optionsWidget->setVisible(false);
    layout.addWidget(optionsWidget);
    connect(sampledRadio, &QRadioButton::toggled, optionsWidget, &QWidget::setVisible);

    QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
    layout.addWidget(buttonBox);
    connect(buttonBox, &QDialogButtonBox::accepted, &dialog, &QDialog::accept);
    connect(buttonBox, &QDialogButtonBox::rejected, &dialog, &QDialog::reject);

    // 2. ë‹¤ì´ì–¼ë¡œê·¸ ì‹¤í–‰
    if (dialog.exec() != QDialog::Accepted) {
        return;
    }

    // 3. íŒŒì¼ ê²½ë¡œ ë¬»ê¸°
    QString fileName = QFileDialog::getSaveFileName(this, "ë‚´ë³´ë‚´ê¸°", "", "JSON íŒŒì¼ (*.json)");
    if (fileName.isEmpty()) return;

    QFile file(fileName);
    if (!file.open(QIODevice::WriteOnly)) {
        QMessageBox::warning(this, "íŒŒì¼ ì˜¤ë¥˜", "íŒŒì¼ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        return;
    }
    
    // 4. ì„ íƒëœ ì˜µì…˜ì— ë”°ë¼ JSON ê°ì²´ ìƒì„±
    QJsonObject rootObj;
    QJsonArray motorsArray;
    MotorProfile* activeProfile = m_document->activeProfile();

    if (allNodesRadio->isChecked()) {
        for (MotorProfile* profile : m_document->motorProfiles()) {
            QJsonObject motorObj;
            profile->write(motorObj);
            motorsArray.append(motorObj);
        }
    } else if (nodesOnlyRadio->isChecked()) {
        if (!activeProfile) {
             QMessageBox::warning(this, "ë‚´ë³´ë‚´ê¸° ì˜¤ë¥˜", "í™œì„± ëª¨í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
             return;
        }
        QJsonObject motorObj;
        activeProfile->write(motorObj);
        motorsArray.append(motorObj);
    } else { // 5ë²ˆ: ìƒ˜í”Œë§ ì‹œ ëª¨ë“  ëª¨í„°
        for (MotorProfile* profile : m_document->motorProfiles()) {
             QJsonObject motorObj;
             profile->exportSamplesToJSON(motorObj, hzSpin->value(), endTimeSpin->value());
             motorsArray.append(motorObj);
        }
    }
    
    rootObj["motors"] = motorsArray;
    
    file.write(QJsonDocument(rootObj).toJson());
    file.close();
    
    statusBar()->showMessage("ë‚´ë³´ë‚´ê¸° ì™„ë£Œ.", 2000);
}

// 1ë²ˆ: (ì‹ ê·œ) ë…¸ë“œ ì„ íƒ ì‹œ í˜¸ì¶œë˜ëŠ” ìŠ¬ë¡¯
void MainWindow::onNodeSelected(QGraphicsItem* selectedNode)
{
    m_selectedNode = qgraphicsitem_cast<GraphNodeItem*>(selectedNode);
    
    if (m_selectedNode) {
        m_nodeEditGroup->setEnabled(true);
        m_nodeXSpin->blockSignals(true);
        m_nodeYSpin->blockSignals(true);
        
        // ì”¬ X ì¢Œí‘œ
        m_nodeXSpin->setValue(m_selectedNode->pos().x());
        
        MotorProfile* profile = m_selectedNode->profile();
        // ì‹¤ì œ Y ê°’ ë²”ìœ„ ë° í˜„ì¬ ê°’ ì„¤ì •
        m_nodeYSpin->setRange(profile->yMin(), profile->yMax());
        m_nodeYSpin->setValue(profile->getRealY(m_selectedNode->pos().y()));
        
        m_nodeXSpin->blockSignals(false);
        m_nodeYSpin->blockSignals(false);
    } else {
        m_nodeEditGroup->setEnabled(false);
        m_nodeXSpin->setValue(0);
        m_nodeYSpin->setValue(0);
        m_selectedNode = nullptr; 
    }
}

// 1ë²ˆ: (ì‹ ê·œ) "ì¢Œí‘œ ì ìš©" ë²„íŠ¼ í´ë¦­ ì‹œ
void MainWindow::onApplyNodeCoords()
{
    if (!m_selectedNode || !m_undoStack) return;

    // "ì‹¤ì œ" ì´ì „ ì¢Œí‘œ
    QPointF oldRealPos = m_selectedNode->profile()->nodeAt(m_selectedNode->index());
    // ìŠ¤í•€ë°•ìŠ¤ì—ì„œ "ì‹¤ì œ" ìƒˆ ì¢Œí‘œ ê°€ì ¸ì˜¤ê¸°
    QPointF newRealPos(m_nodeXSpin->value(), m_nodeYSpin->value());
    
    if (oldRealPos == newRealPos) return; 

    m_undoStack->push(new MoveNodeCommand(m_selectedNode->profile(), 
                                         m_selectedNode->index(), 
                                         oldRealPos, 
                                         newRealPos));
}

