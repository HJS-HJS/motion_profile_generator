네, 두 가지 문제를 모두 수정한 전체 코드를 12개 파일로 나누어 다시 작성해 드립니다.
 * Y축 반전 문제 (1번): grapheditorview.cpp에서 뷰(View)를 scale(1, -1)로 뒤집고, 모든 텍스트(축 숫자, 상/하한선 레이블)가 뒤집히지 않도록 scale(1, -1)로 다시 보정했습니다.
 * 우클릭 편집 문제 (2번): graphnodeitem.cpp의 contextMenuEvent에서 event->accept()를 누락하여 이벤트가 뷰(View)로 전파되던 버그를 수정했습니다.
아래 12개의 파일을 각각 복사하여 사용하시면 됩니다.
1. CMakeLists.txt (변경 없음)
cmake_minimum_required(VERSION 3.16)
project(MotionEditor_Qt5_v2 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(Qt5 REQUIRED COMPONENTS Core Gui Widgets)

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_INCLUDE_CURRENT_DIR ON)

# 실행 파일 생성 (commands.cpp, commands.h 추가)
add_executable(MotionEditor
    main.cpp
    mainwindow.h
    mainwindow.cpp
    motionmodels.h
    motionmodels.cpp
    grapheditorview.h
    grapheditorview.cpp
    graphnodeitem.h
    graphnodeitem.cpp
    commands.h
    commands.cpp
)

target_link_libraries(MotionEditor PRIVATE
    Qt5::Core
    Qt5::Gui
    Qt5::Widgets
)

2. main.cpp (변경 없음)
#include "mainwindow.h"
#include <QApplication>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.setWindowTitle("Profile Orchestrator (Qt 5)");
    w.show();
    return a.exec();
}

3. commands.h (변경 없음)
#pragma once

#include <QUndoCommand>
#include <QPointF>
#include "motionmodels.h" // MotionNode, MotorProfile 사용

// 1. 노드 추가 커맨드
class AddNodeCommand : public QUndoCommand {
public:
    AddNodeCommand(MotorProfile* profile, const MotionNode& node, QUndoCommand* parent = nullptr);
    void undo() override;
    void redo() override;
private:
    MotorProfile* m_profile;
    MotionNode m_node;
    int m_nodeIndex; // undo를 위해 추가된 인덱스 저장
};

// 2. 노드 삭제 커맨드
class DeleteNodeCommand : public QUndoCommand {
public:
    DeleteNodeCommand(MotorProfile* profile, int index, QUndoCommand* parent = nullptr);
    void undo() override;
    void redo() override;
private:
    MotorProfile* m_profile;
    MotionNode m_node; // 복원을 위한 노드 데이터
    int m_nodeIndex;
};

// 3. 노드 이동 커맨드
class MoveNodeCommand : public QUndoCommand {
public:
    MoveNodeCommand(MotorProfile* profile, int index, const QPointF& oldPos, const QPointF& newPos, QUndoCommand* parent = nullptr);
    void undo() override;
    void redo() override;
    // 여러 개의 이동을 하나로 합치기 위한 함수 (드래그 시 유용)
    bool mergeWith(const QUndoCommand* command) override;
    int id() const override { return 1234; } // 병합을 위한 ID

private:
    MotorProfile* m_profile;
    int m_nodeIndex;
    QPointF m_oldPos;
    QPointF m_newPos;
};

4. commands.cpp (변경 없음)
#include "commands.h"
#include <QDebug>

// --- AddNodeCommand ---
AddNodeCommand::AddNodeCommand(MotorProfile* profile, const MotionNode& node, QUndoCommand* parent)
    : QUndoCommand(parent), m_profile(profile), m_node(node), m_nodeIndex(-1) {
    setText("노드 추가");
}

void AddNodeCommand::redo() {
    m_nodeIndex = m_profile->internalAddNode(m_node); // 내부 함수 호출
    // m_profile->sortNodes(); // internalAddNode가 정렬 담당
    m_profile->emitDataChanged(); // 뷰 갱신
}

void AddNodeCommand::undo() {
    if (m_nodeIndex != -1) {
        m_profile->internalRemoveNode(m_nodeIndex); // 내부 함수 호출
        // sortNodes()는 필요 없음
        m_profile->emitDataChanged(); // 뷰 갱신
    }
}

// --- DeleteNodeCommand ---
DeleteNodeCommand::DeleteNodeCommand(MotorProfile* profile, int index, QUndoCommand* parent)
    : QUndoCommand(parent), m_profile(profile), m_nodeIndex(index) {
    m_node = m_profile->nodeAt(index); // 삭제 전 노드 정보 백업
    setText("노드 삭제");
}

void DeleteNodeCommand::redo() {
    m_profile->internalRemoveNode(m_nodeIndex);
    m_profile->emitDataChanged();
}

void DeleteNodeCommand::undo() {
    m_profile->internalAddNode(m_node); // 삭제했던 노드 복원
    // m_profile->sortNodes(); // internalAddNode가 정렬 담당
    m_profile->emitDataChanged();
}


// --- MoveNodeCommand ---
MoveNodeCommand::MoveNodeCommand(MotorProfile* profile, int index, const QPointF& oldPos, const QPointF& newPos, QUndoCommand* parent)
    : QUndoCommand(parent), m_profile(profile), m_nodeIndex(index), m_oldPos(oldPos), m_newPos(newPos) {
    setText("노드 이동");
}

void MoveNodeCommand::redo() {
    m_profile->internalMoveNode(m_nodeIndex, m_newPos);
    m_profile->sortNodes();
    m_profile->emitDataChanged();
}

void MoveNodeCommand::undo() {
    m_profile->internalMoveNode(m_nodeIndex, m_oldPos);
    m_profile->sortNodes();
    m_profile->emitDataChanged();
}

// 드래그 중 발생하는 수많은 이동 커맨드를 하나로 합칩니다.
bool MoveNodeCommand::mergeWith(const QUndoCommand* command) {
    const MoveNodeCommand* moveCommand = static_cast<const MoveNodeCommand*>(command);
    // 같은 노드에 대한 이동 커맨드인지 확인
    if (moveCommand->id() != id() || moveCommand->m_nodeIndex != m_nodeIndex) {
        return false;
    }
    m_newPos = moveCommand->m_newPos; // 최종 위치만 갱신
    return true;
}

5. motionmodels.h (변경 없음)
#pragma once

#include <QObject>
#include <QVector>
#include <QPointF>
#include <QString>
#include <QColor>
#include <QJsonObject>
#include <QVariant>
#include <QTextStream> // Export용

using MotionNode = QPointF; 

class MotorProfile : public QObject {
    Q_OBJECT
    Q_PROPERTY(QString name READ name)
    Q_PROPERTY(QColor color READ color)

public:
    explicit MotorProfile(const QString& name, QColor color, QObject* parent = nullptr);

    // Getters
    const QString& name() const { return m_name; }
    const QColor& color() const { return m_color; }
    const QVector<MotionNode>& nodes() const { return m_nodes; }
    double yMin() const { return m_y_min; }
    double yMax() const { return m_y_max; }
    double maxSlope() const { return m_max_slope; }
    int nodeCount() const { return m_nodes.size(); }
    MotionNode nodeAt(int index) const;

    // Export를 위한 선형 보간 함수
    double sampleAt(double time) const;

    // JSON 직렬화/역직렬화
    void read(const QJsonObject& json);
    void write(QJsonObject& json) const; // 기존 "노드만" 저장 함수
    // 4번: "샘플링"된 데이터를 JSON으로 내보내는 새 함수
    void exportSamplesToJSON(QJsonObject& json, double sampleRateHz, double endTimeSec) const;

    // --- Undo/Redo를 위한 공개 내부 함수 ---
    int internalAddNode(const MotionNode& node);
    void internalRemoveNode(int index);
    void internalMoveNode(int index, const MotionNode& pos);
    void sortNodes(); // 커맨드가 호출할 수 있도록 공개
    void emitDataChanged(); // 커맨드가 호출할 수 있도록 공개

public slots:
    // 7. 제약 조건 Setters
    void setYMin(double val);
    void setYMax(double val);
    void setMaxSlope(double val);

    // 6. 제약조건 적용 슬롯
    void checkAllNodes(); 

signals:
    void dataChanged(); // 노드가 추가, 삭제, 수정될 때
    void constraintsChanged(); // 제약조건이 변경될 때

private:
    bool isNodeValid(const MotionNode& node, int indexToIgnore) const;

    QString m_name;
    QColor m_color;
    QVector<MotionNode> m_nodes;

    double m_y_min = -100.0;
    double m_y_max = 100.0;
    double m_max_slope = 1000.0;
};

class MotionDocument : public QObject {
    Q_OBJECT

public:
    explicit MotionDocument(QObject* parent = nullptr);
    ~MotionDocument();

    const QVector<MotorProfile*>& motorProfiles() const { return m_profiles; }
    MotorProfile* activeProfile() const { return m_activeProfile; }
    int activeProfileIndex() const;

    // Export 로직
    bool exportNodesToStream(QTextStream& stream) const;
    bool exportSamplesToStream(QTextStream& stream, double sampleRateHz, double endTimeSec) const;

public slots:
    MotorProfile* addMotor(const QString& name, QColor color);
    void setActiveMotor(MotorProfile* profile); 
    void removeMotor(MotorProfile* profile);
    
    bool saveToFile(const QString& filename) const;
    bool loadFromFile(const QString& filename);

signals:
    void motorAdded(MotorProfile* profile);
    void documentCleared(); 
    void activeMotorChanged(MotorProfile* active, MotorProfile* previous);
    void modelChanged(); 

private:
    QVector<MotorProfile*> m_profiles;
    MotorProfile* m_activeProfile = nullptr;
};

Q_DECLARE_METATYPE(MotorProfile*)

6. motionmodels.cpp (변경 없음)
#include "motionmodels.h"
#include <QJsonDocument>
#include <QJsonArray>
#include <QFile>
#include <QDebug>
#include <algorithm> // for std::sort
#include <qmath.h> // qBound, qAbs, fmod

// --- MotorProfile 구현 ---
MotorProfile::MotorProfile(const QString& name, QColor color, QObject* parent)
    : QObject(parent), m_name(name), m_color(color) {
}

MotionNode MotorProfile::nodeAt(int index) const {
    if (index < 0 || index >= m_nodes.size()) {
        return MotionNode();
    }
    return m_nodes[index];
}

void MotorProfile::setYMin(double val) {
    if (m_y_min != val) {
        m_y_min = val;
        emit constraintsChanged();
    }
}
void MotorProfile::setYMax(double val) {
    if (m_y_max != val) {
        m_y_max = val;
        emit constraintsChanged();
    }
}
void MotorProfile::setMaxSlope(double val) {
    if (m_max_slope != val) {
        m_max_slope = val;
        emit constraintsChanged();
    }
}

// 6. 제약조건 적용 함수
void MotorProfile::checkAllNodes() {
    bool dataWasChanged = false;
    for (int i = 0; i < m_nodes.size(); ++i) {
        MotionNode node = m_nodes[i];
        double oldY = node.y();
        double clampedY = qBound(m_y_min, oldY, m_y_max);
        
        if (oldY != clampedY) {
            node.setY(clampedY);
            m_nodes[i] = node; // Update node in vector
            dataWasChanged = true;
        }
    }
    if (dataWasChanged) {
        sortNodes(); 
        emit dataChanged(); // 뷰 갱신
    }
}

// Export용 선형 보간 함수
double MotorProfile::sampleAt(double time) const {
    if (m_nodes.isEmpty()) return 0.0;

    // 1번: 0초 이전은 0으로 (X >= 0 제약조건)
    if (time < 0.0) return 0.0;
    
    const MotionNode* prev = nullptr;
    const MotionNode* next = nullptr;
    
    for (int i = 0; i < m_nodes.size(); ++i) {
        if (m_nodes[i].x() <= time) {
            prev = &m_nodes[i];
        } else {
            next = &m_nodes[i];
            break;
        }
    }
    
    // 엣지 케이스
    if (!prev) {
        // 0초와 첫 노드 사이
        // (0,0)에서 시작한다고 가정하고 보간
        const MotionNode& firstNode = m_nodes.first();
        if (firstNode.x() < 1e-6) return firstNode.y();
        double t = time / firstNode.x();
        return 0.0 * (1.0 - t) + firstNode.y() * t;
    }
    if (!next) return m_nodes.last().y();  // 마지막 노드 이후

    // 선형 보간
    if (qAbs(next->x() - prev->x()) < 1e-6) {
        return prev->y(); 
    }
    
    double t = (time - prev->x()) / (next->x() - prev->x());
    return prev->y() * (1.0 - t) + next->y() * t;
}

// 4. 파일 쓰기 (이름, 노드만)
void MotorProfile::write(QJsonObject& json) const {
    json["name"] = m_name;

    QJsonArray nodesArray;
    for (const MotionNode& node : m_nodes) {
        QJsonObject nodeObj;
        nodeObj["time"] = node.x();
        nodeObj["value"] = node.y();
        nodesArray.append(nodeObj);
    }
    json["nodes"] = nodesArray;
}

// 4번: "샘플링"된 데이터를 JSON으로 내보내는 새 함수 구현
void MotorProfile::exportSamplesToJSON(QJsonObject& json, double sampleRateHz, double endTimeSec) const {
    json["name"] = m_name; // 이름은 동일하게
    
    QJsonArray nodesArray;
    if (sampleRateHz <= 0 || endTimeSec < 0) {
        json["nodes"] = nodesArray; // 빈 배열
        return;
    }

    double dt = 1.0 / sampleRateHz;
    
    // X=0 제약조건: 0초부터 샘플링 시작
    for (double time = 0.0; time <= endTimeSec; time += dt) {
        double value = sampleAt(time); // 기존 보간 함수 사용
        QJsonObject nodeObj;
        nodeObj["time"] = time;
        nodeObj["value"] = value;
        nodesArray.append(nodeObj);
    }
    
    // 마지막 샘플 포함 보장
    double lastSampleTime = (qFloor(endTimeSec / dt)) * dt;
    if (endTimeSec - lastSampleTime > 1e-6 && endTimeSec > 0.0) {
        double value = sampleAt(endTimeSec);
        QJsonObject nodeObj;
        nodeObj["time"] = endTimeSec;
        nodeObj["value"] = value;
        nodesArray.append(nodeObj);
    } else if (endTimeSec == 0.0 && dt > 0.0) { // 0초만 내보내기
        double value = sampleAt(0.0);
        QJsonObject nodeObj;
        nodeObj["time"] = 0.0;
        nodeObj["value"] = value;
        nodesArray.append(nodeObj);
    }
    
    json["nodes"] = nodesArray;
}


// 3. 파일 읽기
void MotorProfile::read(const QJsonObject& json) {
    m_name = json["name"].toString(m_name);
    m_nodes.clear();
    QJsonArray nodesArray = json["nodes"].toArray();
    for (const QJsonValue& val : nodesArray) {
        QJsonObject nodeObj = val.toObject();
        m_nodes.append(MotionNode(nodeObj["time"].toDouble(), nodeObj["value"].toDouble()));
    }
    sortNodes();
}

bool MotorProfile::isNodeValid(const MotionNode& node, int indexToIgnore) const {
    // 1번: X >= 0
    if (node.x() < 0.0) {
        qDebug() << "X축 제한 위반:" << node.x();
        return false;
    }
    // Y축 제한
    if (node.y() < m_y_min || node.y() > m_y_max) {
        qDebug() << "Y축 제한 위반:" << node.y();
        return false;
    }
    Q_UNUSED(indexToIgnore); 
    return true;
}

// --- Undo/Redo용 내부 함수 ---
int MotorProfile::internalAddNode(const MotionNode& node) {
    m_nodes.append(node);
    sortNodes(); // 추가 후 즉시 정렬
    return m_nodes.indexOf(node); // 정렬된 위치의 인덱스 반환
}
void MotorProfile::internalRemoveNode(int index) {
    if (index >= 0 && index < m_nodes.size()) {
        m_nodes.remove(index);
    }
}
void MotorProfile::internalMoveNode(int index, const MotionNode& pos) {
    if (index >= 0 && index < m_nodes.size()) {
        m_nodes[index] = pos;
    }
}
void MotorProfile::sortNodes() {
    std::sort(m_nodes.begin(), m_nodes.end(), [](const MotionNode& a, const MotionNode& b) {
        return a.x() < b.x();
    });
}
void MotorProfile::emitDataChanged() {
    emit dataChanged();
}

// --- MotionDocument 구현 ---
MotionDocument::MotionDocument(QObject* parent) : QObject(parent) {}
MotionDocument::~MotionDocument() {
    qDeleteAll(m_profiles);
}
int MotionDocument::activeProfileIndex() const {
    if (!m_activeProfile) return -1;
    return m_profiles.indexOf(m_activeProfile);
}
MotorProfile* MotionDocument::addMotor(const QString& name, QColor color) {
    MotorProfile* profile = new MotorProfile(name, color, this);
    m_profiles.append(profile);
    emit motorAdded(profile);
    emit modelChanged();
    return profile;
}
void MotionDocument::setActiveMotor(MotorProfile* profile) {
    if (profile != m_activeProfile) {
        MotorProfile* oldActive = m_activeProfile;
        m_activeProfile = profile; 
        emit activeMotorChanged(m_activeProfile, oldActive);
    }
}
void MotionDocument::removeMotor(MotorProfile* profile) {
    if (!profile) return;
    int index = m_profiles.indexOf(profile);
    if (index == -1) return;
    m_profiles.removeAt(index);
    if (m_activeProfile == profile) {
        m_activeProfile = nullptr;
        if (!m_profiles.isEmpty()) {
            setActiveMotor(m_profiles.first());
        } else {
            setActiveMotor(nullptr); 
        }
    }
    emit modelChanged(); 
    profile->deleteLater(); 
}
bool MotionDocument::saveToFile(const QString& filename) const {
    QFile file(filename);
    if (!file.open(QIODevice::WriteOnly)) {
        qWarning() << "파일 쓰기 실패:" << filename;
        return false;
    }
    QJsonArray motorsArray;
    for (MotorProfile* profile : m_profiles) {
        QJsonObject motorObj;
        profile->write(motorObj);
        motorsArray.append(motorObj);
    }
    QJsonObject rootObj;
    rootObj["motors"] = motorsArray;
    file.write(QJsonDocument(rootObj).toJson());
    file.close();
    return true;
}
bool MotionDocument::loadFromFile(const QString& filename) {
    QFile file(filename);
    if (!file.open(QIODevice::ReadOnly)) {
        qWarning() << "파일 읽기 실패:" << filename;
        return false;
    }
    QByteArray data = file.readAll();
    QJsonDocument doc = QJsonDocument::fromJson(data);
    if (doc.isNull() || !doc.isObject()) {
        qWarning() << "잘못된 JSON 형식:" << filename;
        return false;
    }
    emit documentCleared();
    qDeleteAll(m_profiles);
    m_profiles.clear();
    m_activeProfile = nullptr;
    QJsonObject rootObj = doc.object();
    QJsonArray motorsArray = rootObj["motors"].toArray();
    for (const QJsonValue& val : motorsArray) {
        QJsonObject motorObj = val.toObject();
        QColor color = QColor::fromHsv(qrand() % 360, 200, 200); 
        MotorProfile* profile = new MotorProfile("", color, this); 
        profile->read(motorObj);
        m_profiles.append(profile);
        emit motorAdded(profile); 
    }
    emit modelChanged(); 
    if (!m_profiles.isEmpty()) {
        setActiveMotor(m_profiles.first());
    }
    return true;
}

// --- Export 로직 (CSV용 - 현재 사용 안 함) ---
bool MotionDocument::exportNodesToStream(QTextStream& stream) const {
    if (!m_activeProfile) return false;
    stream << "Motor: " << m_activeProfile->name() << "\n";
    stream << "Time (s),Value\n";
    for (const MotionNode& node : m_activeProfile->nodes()) {
        stream << node.x() << "," << node.y() << "\n";
    }
    return true;
}
bool MotionDocument::exportSamplesToStream(QTextStream& stream, double sampleRateHz, double endTimeSec) const {
    if (!m_activeProfile || sampleRateHz <= 0) return false;
    stream << "Motor: " << m_activeProfile->name() << "\n";
    stream << "SampleRate: " << sampleRateHz << " Hz\n";
    stream << "Time (s),Value\n";
    double dt = 1.0 / sampleRateHz;
    if (m_activeProfile->nodes().isEmpty()) return true;
    double startTime = 0.0; // 0초부터
    if (endTimeSec < startTime) endTimeSec = m_activeProfile->nodes().last().x();
    for (double time = startTime; time <= endTimeSec; time += dt) {
        double value = m_activeProfile->sampleAt(time);
        stream << time << "," << value << "\n";
    }
    if (fmod(endTimeSec - startTime, dt) != 0.0) {
        double value = m_activeProfile->sampleAt(endTimeSec);
        stream << endTimeSec << "," << value << "\n";
    }
    return true;
}

7. graphnodeitem.h (변경 없음)
#pragma once

#include <QGraphicsEllipseItem>
#include <QObject> 
#include <QPointF> // QPointF 사용

class MotorProfile;
class GraphEditorView; // 뷰 포인터 (스냅용)
class QUndoStack; // Undo 스택 포인터

class GraphNodeItem : public QObject, public QGraphicsEllipseItem {
    Q_OBJECT

public:
    // 생성자 수정
    GraphNodeItem(MotorProfile* profile, int index, 
                  GraphEditorView* view, QUndoStack* stack, 
                  QGraphicsItem* parent = nullptr);
    
    MotorProfile* profile() const { return m_profile; }
    int index() const { return m_nodeIndex; }
    void setNodeIndex(int index) { m_nodeIndex = index; } // 인덱스 변경 시 필요

protected:
    // 1. 우클릭
    void contextMenuEvent(QGraphicsSceneContextMenuEvent *event) override;
    // 1. 좌클릭 드래그 시작/종료
    void mousePressEvent(QGraphicsSceneMouseEvent* event) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent* event) override;
    // 7. 스냅
    QVariant itemChange(GraphicsItemChange change, const QVariant& value) override;

private slots:
    // 7. 좌표 동시 편집
    void onEditTriggered();  
    void onDeleteTriggered();

private:
    MotorProfile* m_profile;
    int m_nodeIndex;
    QPointF m_dragStartPosition;
    
    GraphEditorView* m_view; // 스냅 기능용
    QUndoStack* m_undoStack; // Undo/Redo용
};

8. graphnodeitem.cpp (수정됨)
#include "graphnodeitem.h"
#include "grapheditorview.h" // 스냅 기능
#include "commands.h" // 커맨드
#include <QUndoStack> // Undo 스택
#include <QGraphicsSceneMouseEvent>
#include <QMenu>
#include <QPen>
#include <QBrush>
#include <QDebug>
#include <QDialog>
#include <QFormLayout>
#include <QDoubleSpinBox>
#include <QDialogButtonBox>
#include <qmath.h> // qRound, qMax

// 생성자 수정
GraphNodeItem::GraphNodeItem(MotorProfile* profile, int index, 
                             GraphEditorView* view, QUndoStack* stack, 
                             QGraphicsItem* parent)
    : QObject(nullptr), QGraphicsEllipseItem(parent), 
      m_profile(profile), m_nodeIndex(index), 
      m_view(view), m_undoStack(stack)
{
    // 노드의 그래픽 속성 설정
    setRect(-5, -5, 10, 10); // 10x10 크기
    setPen(QPen(Qt::black, 1));
    setBrush(QBrush(profile->color()));
    
    setFlag(QGraphicsItem::ItemIsMovable);
    setFlag(QGraphicsItem::ItemSendsGeometryChanges); // itemChange() 활성화
    setFlag(QGraphicsItem::ItemIsSelectable); // Delete 키를 위해 추가
    
    setPos(m_profile->nodeAt(m_nodeIndex));
}

// 1. 좌클릭 드래그 시작
void GraphNodeItem::mousePressEvent(QGraphicsSceneMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        m_dragStartPosition = pos(); 
    }
    QGraphicsEllipseItem::mousePressEvent(event);
}

// 1. 좌클릭 드래그 종료 -> MoveNodeCommand 생성
void GraphNodeItem::mouseReleaseEvent(QGraphicsSceneMouseEvent* event) {
    QGraphicsEllipseItem::mouseReleaseEvent(event);
    
    if (event->button() == Qt::LeftButton && pos() != m_dragStartPosition) {
        m_undoStack->push(new MoveNodeCommand(m_profile, m_nodeIndex, m_dragStartPosition, pos()));
    }
}

// 1. 우클릭 메뉴
void GraphNodeItem::contextMenuEvent(QGraphicsSceneContextMenuEvent *event) {
    // 3번: 선택된 상태가 아니면 무시 (뷰의 contextMenu가 처리하도록)
    if (!isSelected()) {
        event->ignore();
        return;
    }
    
    QMenu menu;
    QAction* editAction = menu->addAction("좌표 수정");
    QAction* deleteAction = menu.addAction("노드 삭제");

    connect(editAction, &QAction::triggered, this, &GraphNodeItem::onEditTriggered);
    connect(deleteAction, &QAction::triggered, this, &GraphNodeItem::onDeleteTriggered);
    
    menu.exec(event->screenPos());
    event->accept(); // 2번: 버그 수정 (이벤트가 뷰로 전파되는 것을 막음)
}

// 스냅 기능 추가 (Feature 3b)
QVariant GraphNodeItem::itemChange(GraphicsItemChange change, const QVariant& value) {
    if (change == ItemPositionChange && scene()) {
        QPointF newPos = value.toPointF();

        // 1. 스냅 기능
        if (m_view && m_view->isSnapEnabled()) {
            double gridSize = m_view->gridSize();
            if (gridSize > 0) {
                newPos.setX(qRound(newPos.x() / gridSize) * gridSize);
                newPos.setY(qRound(newPos.y() / gridSize) * gridSize);
            }
        }
        
        // 1번: X좌표는 0 이하로 내려가지 않음
        newPos.setX(qMax(0.0, newPos.x()));

        // 2. Y축 제한
        double clampedY = qBound(m_profile->yMin(), newPos.y(), m_profile->yMax());
        newPos.setY(clampedY);
        
        return newPos;
    }
    return QGraphicsItem::itemChange(change, value);
}

// 7. 좌표 동시 편집 -> MoveNodeCommand 생성
void GraphNodeItem::onEditTriggered() {
    MotionNode currentNode = m_profile->nodeAt(m_nodeIndex);
    
    QDialog dialog;
    dialog.setWindowTitle("좌표 수정");
    QFormLayout layout(&dialog);
    
    QDoubleSpinBox* xSpin = new QDoubleSpinBox();
    xSpin->setDecimals(3);
    // 1번: X좌표(시간)의 최소값을 0으로 설정
    xSpin->setRange(0.0, 100000.0);
    xSpin->setValue(currentNode.x());
    layout.addRow("Time (X):", xSpin);

    QDoubleSpinBox* ySpin = new QDoubleSpinBox();
    ySpin->setDecimals(3);
    ySpin->setRange(m_profile->yMin(), m_profile->yMax());
    ySpin->setValue(currentNode.y());
    layout.addRow("Value (Y):", ySpin);

    QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
    layout.addRow(buttonBox);

    connect(buttonBox, &QDialogButtonBox::accepted, &dialog, &QDialog::accept);
    connect(buttonBox, &QDialogButtonBox::rejected, &dialog, &QDialog::reject);

    if (dialog.exec() == QDialog::Accepted) {
        double newTime = xSpin->value();
        double newValue = ySpin->value();
        m_undoStack->push(new MoveNodeCommand(m_profile, m_nodeIndex, currentNode, QPointF(newTime, newValue)));
    }
}

// 5. 노드 삭제 -> DeleteNodeCommand 생성
void GraphNodeItem::onDeleteTriggered() {
    m_undoStack->push(new DeleteNodeCommand(m_profile, m_nodeIndex));
}

9. grapheditorview.h (변경 없음)
#pragma once

#include <QGraphicsView>
#include <QMap>
#include <QList>
#include <qmath.h> // qFloor, qBound

class MotionDocument;
class MotorProfile;
class QGraphicsItem;
class QUndoStack; // Undo 스택
class QKeyEvent; // Delete 키

class GraphEditorView : public QGraphicsView {
    Q_OBJECT

public:
    explicit GraphEditorView(QWidget* parent = nullptr);
    void setDocument(MotionDocument* doc);
    
    void setUndoStack(QUndoStack* stack) { m_undoStack = stack; }
    
    bool isSnapEnabled() const { return m_snapToGrid; }
    double gridSize() const { return m_gridSize; }

public slots:
    void fitToView(); // Fit 기능 슬롯
    void toggleSnapToGrid(bool checked) { m_snapToGrid = checked; }
    // 1. 활성 모터의 Y축(min/max)에 맞게 뷰를 자동 조절하는 슬롯
    void fitToActiveMotor(MotorProfile* profile);

protected:
    void wheelEvent(QWheelEvent* event) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void contextMenuEvent(QContextMenuEvent* event) override;
    
    // Delete 키 (Feature 3a)
    void keyPressEvent(QKeyEvent* event) override; 

    void drawBackground(QPainter* painter, const QRectF& rect) override;

private slots:
    void onDocumentCleared();
    void onMotorAdded(MotorProfile* profile);
    void onActiveMotorChanged(MotorProfile* active, MotorProfile* previous);
    void onProfileDataChanged();
    void onProfileConstraintsChanged();

    // 5. 축 값 업데이트 슬롯
    void updateConstraintItems(MotorProfile* profile);


private:
    void rebuildProfileItems(MotorProfile* profile);
    void updateProfileVisibility(MotorProfile* profile, bool isActive);
    void clearAllProfileItems();

    // 5. 축 값 아이템(라인, 텍스트)을 별도로 관리
    QMap<MotorProfile*, QList<QGraphicsItem*>> m_constraintItems; 
    void setConstraintItemsVisible(MotorProfile* profile, bool visible);

    QUndoStack* m_undoStack = nullptr; // Undo 스택
    
    bool m_snapToGrid = false;
    double m_gridSize = 10.0;
    
    QGraphicsScene* m_scene;
    MotionDocument* m_document = nullptr;
    QMap<MotorProfile*, QList<QGraphicsItem*>> m_profileItems;
    bool m_isPanning = false;
    QPoint m_panStartPos;
};

10. grapheditorview.cpp (수정됨)
#include "grapheditorview.h"
#include "motionmodels.h"
#include "graphnodeitem.h"
#include "commands.h" // 커맨드
#include <QUndoStack> // Undo 스택
#include <QKeyEvent> // Delete 키
#include <QWheelEvent>
#include <QMouseEvent>
#include <QContextMenuEvent>
#include <QMenu>
#include <QScrollBar>
#include <QGraphicsLineItem>
#include <QGraphicsTextItem> // 축 값
#include <QPen>
#include <QBrush>
#include <QDebug>
#include <QTransform> // 1번: Y축 반전

GraphEditorView::GraphEditorView(QWidget* parent)
    : QGraphicsView(parent), m_scene(new QGraphicsScene(this)), m_isPanning(false)
{
    setScene(m_scene);
    setRenderHint(QPainter::Antialiasing); 
    setDragMode(QGraphicsView::NoDrag); 
    setTransformationAnchor(AnchorUnderMouse);
    setAlignment(Qt::AlignCenter); 
    m_scene->setSceneRect(-10000, -10000, 20000, 20000); 
    setFocusPolicy(Qt::StrongFocus); // Delete 키
    
    // 1번: Y축을 반전시킵니다. (Y=0이 하단, Y>0이 상단)
    scale(1, -1);
}

void GraphEditorView::setDocument(MotionDocument* doc) {
    if (m_document) {
        disconnect(m_document, nullptr, this, nullptr);
    }
    m_document = doc;
    if (!m_document) return;

    connect(m_document, &MotionDocument::documentCleared, this, &GraphEditorView::onDocumentCleared);
    connect(m_document, &MotionDocument::motorAdded, this, &GraphEditorView::onMotorAdded);
    connect(m_document, &MotionDocument::activeMotorChanged, this, &GraphEditorView::onActiveMotorChanged);
    
    for(MotorProfile* profile : m_document->motorProfiles()) {
        onMotorAdded(profile);
    }
    onActiveMotorChanged(m_document->activeProfile(), nullptr);
}

// --- 이벤트 오버라이드 ---
void GraphEditorView::wheelEvent(QWheelEvent* event) {
    double scaleFactor = (event->angleDelta().y() > 0) ? 1.15 : 1.0 / 1.15;
    scale(scaleFactor, scaleFactor);
}
void GraphEditorView::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::MiddleButton) {
        m_isPanning = true;
        m_panStartPos = event->pos();
        setCursor(Qt::ClosedHandCursor);
        event->accept();
        return;
    }
    QGraphicsView::mousePressEvent(event);
}
void GraphEditorView::mouseReleaseEvent(QMouseEvent* event) {
    if (event->button() == Qt::MiddleButton) {
        m_isPanning = false;
        setCursor(Qt::ArrowCursor);
        event->accept();
        return;
    }
    QGraphicsView::mouseReleaseEvent(event);
}
void GraphEditorView::mouseMoveEvent(QMouseEvent* event) {
    if (m_isPanning) {
        horizontalScrollBar()->setValue(horizontalScrollBar()->value() - (event->pos().x() - m_panStartPos.x()));
        verticalScrollBar()->setValue(verticalScrollBar()->value() - (event->pos().y() - m_panStartPos.y()));
        m_panStartPos = event->pos(); 
        event->accept();
        return;
    }
    QGraphicsView::mouseMoveEvent(event);
}

// 2. 우클릭 -> AddNodeCommand 생성
void GraphEditorView::contextMenuEvent(QContextMenuEvent* event) {
    // 3번: 노드를 우클릭한 경우(GraphNodeItem::contextMenuEvent가 accept됨)
    // 이 이벤트는 호출되지 않습니다.
    // 따라서 이 함수는 배경을 우클릭한 경우에만 호출됩니다.
    
    if (!m_document || !m_document->activeProfile() || !m_undoStack) return;

    QPointF scenePos = mapToScene(event->pos());
    MotorProfile* activeProfile = m_document->activeProfile();

    QMenu menu;
    QAction* addAction = menu.addAction("여기( " + 
        QString::number(scenePos.x(), 'f', 2) + ", " + 
        QString::number(scenePos.y(), 'f', 2) + 
        " )에 새 노드 추가");

    // 1번: X좌표가 0 미만인 곳에는 노드 추가 비활성화
    if (scenePos.x() < 0) {
        addAction->setEnabled(false);
        addAction->setText(addAction->text() + " (X < 0 불가)");
    }
    // Y축 제한 (기존)
    else if (scenePos.y() < activeProfile->yMin() || scenePos.y() > activeProfile->yMax()) {
        addAction->setEnabled(false);
        addAction->setText(addAction->text() + " (Y축 제한 위반)");
    }
    
    connect(addAction, &QAction::triggered, this, [=]() {
        m_undoStack->push(new AddNodeCommand(activeProfile, scenePos));
    });
    
    menu.exec(event->globalPos());
}

// 3a. Delete 키 구현
void GraphEditorView::keyPressEvent(QKeyEvent* event) {
    if (event->key() == Qt::Key_Delete) {
        if (!m_document || !m_document->activeProfile() || !m_undoStack) return;
        QList<GraphNodeItem*> itemsToDelete;
        for (QGraphicsItem* item : m_scene->selectedItems()) {
            if (auto nodeItem = qgraphicsitem_cast<GraphNodeItem*>(item)) {
                itemsToDelete.append(nodeItem);
            }
        }
        if (itemsToDelete.isEmpty()) return;
        std::sort(itemsToDelete.begin(), itemsToDelete.end(), [](auto a, auto b) {
            return a->index() > b->index();
        });
        m_undoStack->beginMacro("선택된 노드 삭제");
        for (GraphNodeItem* item : itemsToDelete) {
            m_undoStack->push(new DeleteNodeCommand(item->profile(), item->index()));
        }
        m_undoStack->endMacro();
        event->accept();
    } else {
        QGraphicsView::keyPressEvent(event);
    }
}

void GraphEditorView::drawBackground(QPainter* painter, const QRectF& rect) {
    QGraphicsView::drawBackground(painter, rect);
    QPen pen(QColor(220, 220, 220), 0); 
    pen.setCosmetic(true);
    painter->setPen(pen);
    double gridSize = m_gridSize; 
    double left = qFloor(rect.left() / gridSize) * gridSize;
    double top = qFloor(rect.top() / gridSize) * gridSize;
    for (double x = left; x < rect.right(); x += gridSize) {
        painter->drawLine(QPointF(x, rect.top()), QPointF(x, rect.bottom()));
    }
    for (double y = top; y < rect.bottom(); y += gridSize) {
        painter->drawLine(QPointF(rect.left(), y), QPointF(rect.right(), y));
    }
    painter->setPen(QPen(QColor(180, 180, 180), 0));
    painter->drawLine(QPointF(0, rect.top()), QPointF(0, rect.bottom())); // Y축
    painter->drawLine(QPointF(rect.left(), 0), QPointF(rect.right(), 0)); // X축

    
    // 1번, 2번: Y축 반전 상태에서 축 숫자 값 표시
    painter->save(); // 현재 (1, -1) 변환 상태 저장
    painter->scale(1, -1); // 로컬에서 (1, 1)로 다시 뒤집음

    painter->setPen(QPen(Qt::black));
    QFont font = painter->font();
    font.setPointSizeF(8); 
    painter->setFont(font);

    // Y=0 (X축)을 따라 숫자 표시
    for (double x = left; x < rect.right(); x += gridSize) {
        if (qAbs(x) > 1e-3) { 
            // scene y=2 (축 바로 아래)에 그립니다.
            painter->drawText(QRectF(x - 50, 2, 100, 20), Qt::AlignHCenter | Qt::AlignTop, QString::number(x));
        }
    }
    
    // X=0 (Y축)을 따라 숫자 표시
    for (double y = top; y < rect.bottom(); y += gridSize) {
        if (qAbs(y) > 1e-3) { 
             // scene y=y에 그립니다. (scale(1,-1)로 인해 -y 위치에 그려짐)
             painter->drawText(QRectF(2, y - 10, 50, 20), Qt::AlignLeft | Qt::AlignVCenter, QString::number(y));
        }
    }
    
    painter->restore(); // (1, -1) 변환 상태 복원
}

// --- 슬롯 구현 ---
void GraphEditorView::onDocumentCleared() {
    clearAllProfileItems();
    for(const auto& list : m_constraintItems) {
        qDeleteAll(list);
    }
    m_constraintItems.clear();
}
void GraphEditorView::clearAllProfileItems() {
    for(const auto& items : m_profileItems) {
        for(QGraphicsItem* item : items) {
            m_scene->removeItem(item);
            delete item;
        }
    }
}
void GraphEditorView::onMotorAdded(MotorProfile* profile) {
    if (!profile || m_profileItems.contains(profile)) return;
    m_profileItems.insert(profile, QList<QGraphicsItem*>());
    rebuildProfileItems(profile);
    updateProfileVisibility(profile, false); 
    connect(profile, &MotorProfile::dataChanged, this, &GraphEditorView::onProfileDataChanged);
    connect(profile, &MotorProfile::constraintsChanged, this, &GraphEditorView::onProfileConstraintsChanged);
}
void GraphEditorView::onActiveMotorChanged(MotorProfile* active, MotorProfile* previous) {
    if (previous) {
        updateProfileVisibility(previous, false);
        setConstraintItemsVisible(previous, false); 
    }
    if (active) {
        updateProfileVisibility(active, true);
        updateConstraintItems(active); 
        setConstraintItemsVisible(active, true);  
    }
    
    // 뷰 자동 조절은 MainWindow::onActiveMotorSwitched에서 호출
}
void GraphEditorView::onProfileDataChanged() {
    MotorProfile* profile = qobject_cast<MotorProfile*>(sender());
    if (profile) {
        rebuildProfileItems(profile);
        updateProfileVisibility(profile, (profile == m_document->activeProfile()));
    }
}
void GraphEditorView::onProfileConstraintsChanged() {
    MotorProfile* profile = qobject_cast<MotorProfile*>(sender());
     if (profile) {
        updateConstraintItems(profile);
     }
}
void GraphEditorView::rebuildProfileItems(MotorProfile* profile) {
    if (!profile) return;
    if (m_profileItems.contains(profile)) {
        for (QGraphicsItem* item : m_profileItems.value(profile)) {
            m_scene->removeItem(item);
            delete item;
        }
        m_profileItems[profile].clear();
    }
    QList<QGraphicsItem*>& items = m_profileItems[profile];
    const auto& nodes = profile->nodes();
    QColor color = profile->color();
    QPen linePen(color, 2); 
    for (int i = 0; i < nodes.size() - 1; ++i) {
        QGraphicsLineItem* line = m_scene->addLine(QLineF(nodes[i], nodes[i+1]), linePen);
        items.append(line);
    }
    for (int i = 0; i < nodes.size(); ++i) {
        GraphNodeItem* nodeItem = new GraphNodeItem(profile, i, this, m_undoStack); // view, stack 전달
        m_scene->addItem(nodeItem);
        items.append(nodeItem);
    }
}
void GraphEditorView::updateProfileVisibility(MotorProfile* profile, bool isActive) {
    if (!profile || !m_profileItems.contains(profile)) return;
    QList<QGraphicsItem*>& items = m_profileItems[profile];
    QColor color = profile->color();
    qreal opacity;
    int zValue;
    if (isActive) {
        opacity = 1.0;
        zValue = 1; 
    } else {
        color.setAlpha(60); 
        opacity = 0.5;
        zValue = 0; 
    }
    for (QGraphicsItem* item : items) {
        item->setZValue(zValue);
        item->setOpacity(opacity);
        item->setEnabled(isActive); 
        if (auto line = qgraphicsitem_cast<QGraphicsLineItem*>(item)) {
            QPen pen = line->pen();
            pen.setColor(color);
            line->setPen(pen);
        } else if (auto node = qgraphicsitem_cast<GraphNodeItem*>(item)) {
            node->setBrush(QBrush(color));
            node->setPen(QPen(isActive ? Qt::black : color.darker(120), 1));
        }
    }
}

// 5. 축 값 (상/하한선) 그리기
void GraphEditorView::updateConstraintItems(MotorProfile* profile) {
    if (!profile) return;

    if (m_constraintItems.contains(profile)) {
        qDeleteAll(m_constraintItems.value(profile));
        m_constraintItems[profile].clear();
    } else {
        m_constraintItems.insert(profile, QList<QGraphicsItem*>());
    }

    QList<QGraphicsItem*>& items = m_constraintItems[profile];
    QRectF r = sceneRect(); 
    double yMin = profile->yMin();
    double yMax = profile->yMax();
    QColor color = profile->color();
    color.setAlpha(150); 

    // 1. 굵은 실선
    QPen linePen(color, 3, Qt::SolidLine); 

    QGraphicsLineItem* minLine = m_scene->addLine(r.left(), yMin, r.right(), yMin, linePen);
    QGraphicsLineItem* maxLine = m_scene->addLine(r.left(), yMax, r.right(), yMax, linePen);
    minLine->setZValue(-1); 
    maxLine->setZValue(-1);
    items.append(minLine);
    items.append(maxLine);

    // 1번: Y축 반전 보정 (텍스트 아이템 스케일 뒤집기)
    QGraphicsTextItem* minLabel = m_scene->addText(QString::number(yMin, 'f', 1));
    minLabel->setTransform(QTransform::fromScale(1, -1)); // 텍스트 뒤집기
    minLabel->setPos(r.left() + 5, yMin + minLabel->boundingRect().height()); // 라인 *아래*에 표시
    minLabel->setDefaultTextColor(color);
    minLabel->setZValue(-1);
    items.append(minLabel);

    QGraphicsTextItem* maxLabel = m_scene->addText(QString::number(yMax, 'f', 1));
    maxLabel->setTransform(QTransform::fromScale(1, -1)); // 텍스트 뒤집기
    maxLabel->setPos(r.left() + 5, yMax); // 라인 *위*에 표시 (기본 위치)
    maxLabel->setDefaultTextColor(color);
    maxLabel->setZValue(-1);
    items.append(maxLabel);

    setConstraintItemsVisible(profile, (profile == m_document->activeProfile()));
}
void GraphEditorView::setConstraintItemsVisible(MotorProfile* profile, bool visible) {
    if (!m_constraintItems.contains(profile)) return;
    for (QGraphicsItem* item : m_constraintItems.value(profile)) {
        item->setVisible(visible);
    }
}

// 3c. Fit to View 슬롯 (전체 아이템 기준)
void GraphEditorView::fitToView() {
    if (m_scene->items().isEmpty()) {
        // 씬이 비어있으면 기본 뷰로 (0,0) 주변을 보여줌
        fitInView(QRectF(-100, -100, 200, 200), Qt::KeepAspectRatio);
        return;
    }
    
    QRectF bounds = m_scene->itemsBoundingRect();
    if (bounds.isValid()) {
        // 1번: Y축이 반전되었으므로 0축이 상단이 아님.
        // Y=0 축이 항상 포함되도록 Y *하단*(top)을 0 이하로, Y *상단*(bottom)을 0 이상으로
        if (bounds.top() > 0.0) bounds.setTop(0.0);
        if (bounds.bottom() < 0.0) bounds.setBottom(0.0);
        
        fitInView(bounds.marginsAdded(QMarginsF(20, 20, 20, 20)), Qt::KeepAspectRatio);
    }
}

// 1. 활성 모터의 Y축 제약조건 기준으로 뷰를 맞추는 함수
void GraphEditorView::fitToActiveMotor(MotorProfile* profile)
{
    if (!profile) {
        fitToView();
        return;
    }

    double yMin = profile->yMin();
    double yMax = profile->yMax();
    double xMin = 0.0; // 1번: X=0부터
    double xMax = 100.0; // 기본 X 범위

    if (!profile->nodes().isEmpty()) {
        for (const auto& node : profile->nodes()) {
            if (node.x() > xMax) xMax = node.x();
        }
    }
    if (xMax < 10.0) xMax = 10.0; // 최소 10초 범위

    if (qAbs(yMax - yMin) < 1e-6) {
        yMin -= 50.0;
        yMax += 50.0;
    }

    // 1번: Y축 반전으로 QRectF 생성 방식 변경 (TopLeft, BottomRight)
    // Top(yMax) > Bottom(yMin)
    QRectF motorBounds(QPointF(xMin, yMax), QPointF(xMax, yMin));

    double yMargin = qAbs(yMax - yMin) * 0.1;
    double xMargin = qAbs(xMax - xMin) * 0.1;
    if (xMargin < 20) xMargin = 20;

    fitInView(motorBounds.marginsAdded(QMarginsF(xMargin, yMargin, xMargin, yMargin)), Qt::KeepAspectRatio);
}

11. mainwindow.h (변경 없음)
#pragma once

#include <QMainWindow>

// Qt 5.7 미만인 경우 QOverload 대신 static_cast 사용
#if QT_VERSION < QT_VERSION_CHECK(5, 7, 0)
// static_cast를 사용하므로 별도 헤더 필요 없음
#else
#include <QOverload> 
#endif

// 전방 선언
class MotionDocument;
class GraphEditorView;
class MotorProfile;
class QTreeWidget;
class QTreeWidgetItem;
class QDoubleSpinBox;
class QToolButton; 
class QPushButton; 
class QUndoStack; // Undo 스택
class QAction;

class MainWindow : public QMainWindow {
    Q_OBJECT

public:
    MainWindow(QWidget* parent = nullptr);
    ~MainWindow();

private slots:
    void onMotorSelectionChanged(QTreeWidgetItem* current, QTreeWidgetItem* previous);
    void onAddMotor();
    void onRemoveMotor();
    void onSaveDocument();
    void onLoadDocument();
    
    void onExportDocument(); // Export
    void onFitToView();      // Fit
    
    void onApplyConstraints();
    void onDocumentModelChanged();
    void onActiveMotorSwitched(MotorProfile* active, MotorProfile* previous);

private:
    void createActions();
    void createMenus();
    void createDocks();
    
    void connectProfileToSpinBoxes(MotorProfile* profile);
    void disconnectProfileFromSpinBoxes(MotorProfile* profile);

    MotionDocument* m_document;
    GraphEditorView* m_view;

    QUndoStack* m_undoStack; // Undo 스택
    
    QTreeWidget* m_motorTreeWidget;
    QTreeWidgetItem* m_motorsRootItem; 
    QToolButton* m_addMotorButton;
    QToolButton* m_removeMotorButton;

    QDoubleSpinBox* m_yMinSpin;
    QDoubleSpinBox* m_yMaxSpin;
    QDoubleSpinBox* m_slopeSpin;
    QPushButton* m_applyConstraintsButton;
    
    // 메뉴 액션
    QAction* m_saveAction;
    QAction* m_loadAction;
    QAction* m_exportAction; 
    QAction* m_undoAction;   
    QAction* m_redoAction;   
    QAction* m_fitToViewAction; 
    QAction* m_snapGridAction;  
};

12. mainwindow.cpp (수정됨)
#include "mainwindow.h"
#include "motionmodels.h"
#include "grapheditorview.h"

#include <QMenu>
#include <QMenuBar>
#include <QDockWidget>
#include <QTreeWidget>
#include <QTreeWidgetItem>
#include <QHeaderView>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QToolButton>
#include <QPushButton>
#include <QFormLayout>
#include <QDoubleSpinBox>
#include <QSpinBox> // Export
#include <QRadioButton> // Export
#include <QDialogButtonBox> // Export
#include <QFileDialog>
#include <QInputDialog>
#include <QMessageBox>
#include <QStatusBar>
#include <QUndoStack> // Undo 스택
// #include <QTextStream> // 4번: JSON으로 내보내므로 더 이상 필요 없음
#include <QDebug> // qrand
#include <QTime> // qsrand

MainWindow::MainWindow(QWidget* parent)
    : QMainWindow(parent)
{
    // 0. Undo 스택 생성
    m_undoStack = new QUndoStack(this);

    // 1. 모델
    m_document = new MotionDocument(this);

    // 1. 뷰
    m_view = new GraphEditorView(this);
    m_view->setDocument(m_document);
    m_view->setUndoStack(m_undoStack); // 뷰에 Undo 스택 전달
    setCentralWidget(m_view); 

    createActions();
    createMenus();
    createDocks(); 
    
    // 시그널 연결
    connect(m_motorTreeWidget, &QTreeWidget::currentItemChanged, 
            this, &MainWindow::onMotorSelectionChanged);
    connect(m_document, &MotionDocument::modelChanged, 
            this, &MainWindow::onDocumentModelChanged);
    connect(m_document, &MotionDocument::activeMotorChanged, 
            this, &MainWindow::onActiveMotorSwitched);
    connect(m_fitToViewAction, &QAction::triggered, m_view, &GraphEditorView::fitToView);
    connect(m_snapGridAction, &QAction::toggled, m_view, &GraphEditorView::toggleSnapToGrid);
            
    // 초기 모터 추가 (테스트용)
    qsrand(QTime::currentTime().msec()); // 랜덤 시드
    MotorProfile* m1 = m_document->addMotor("Motor 1 (Red)", Qt::red);
    m1->internalAddNode(QPointF(0, 0));
    m1->internalAddNode(QPointF(200, 50));
    MotorProfile* m2 = m_document->addMotor("Motor 4 (Blue)", Qt::blue);
    m2->internalAddNode(QPointF(50, -30));
    m2->internalAddNode(QPointF(150, 80));

    onDocumentModelChanged(); // 트리 갱신
    
    if (m_motorsRootItem->childCount() > 0) {
        m_motorsRootItem->child(0)->setSelected(true);
    }

    m_undoStack->clear(); // 초기화 후 Undo 스택 비우기
    setMinimumSize(800, 600);
    setWindowTitle("Profile Orchestrator (Qt 5)"); 
}

MainWindow::~MainWindow() {}

void MainWindow::createActions() {
    m_saveAction = new QAction("저장 (&S)", this);
    m_saveAction->setShortcut(QKeySequence::Save);
    connect(m_saveAction, &QAction::triggered, this, &MainWindow::onSaveDocument);

    m_loadAction = new QAction("불러오기 (&O)", this);
    m_loadAction->setShortcut(QKeySequence::Open);
    connect(m_loadAction, &QAction::triggered, this, &MainWindow::onLoadDocument);

    m_exportAction = new QAction("내보내기 (&E)...", this);
    connect(m_exportAction, &QAction::triggered, this, &MainWindow::onExportDocument);

    m_undoAction = m_undoStack->createUndoAction(this, "실행 취소 (&U)");
    m_undoAction->setShortcut(QKeySequence::Undo);
    m_redoAction = m_undoStack->createRedoAction(this, "다시 실행 (&R)");
    m_redoAction->setShortcut(QKeySequence::Redo);

    m_fitToViewAction = new QAction("전체 보기 (&F)", this);
    m_fitToViewAction->setShortcut(Qt::Key_F);
    
    m_snapGridAction = new QAction("그리드에 맞추기 (&G)", this);
    m_snapGridAction->setCheckable(true);
    m_snapGridAction->setShortcut(Qt::Key_G);
}

void MainWindow::createMenus() {
    QMenu* fileMenu = menuBar()->addMenu("파일 (&F)");
    fileMenu->addAction(m_loadAction);
    fileMenu->addAction(m_saveAction);
    fileMenu->addAction(m_exportAction);
    
    QMenu* editMenu = menuBar()->addMenu("편집 (&E)");
    editMenu->addAction(m_undoAction);
    editMenu->addAction(m_redoAction);
    editMenu->addSeparator();
    editMenu->addAction(m_snapGridAction);
    
    QMenu* viewMenu = menuBar()->addMenu("보기 (&V)");
    viewMenu->addAction(m_fitToViewAction);
}

void MainWindow::createDocks() {
    // 8. 좌측 모터 선택창
    QDockWidget* leftDock = new QDockWidget("Object", this);
    QWidget* motorListWidget = new QWidget; 
    QVBoxLayout* motorLayout = new QVBoxLayout(motorListWidget);
    motorLayout->setContentsMargins(0,0,0,0);
    motorLayout->setSpacing(0);

    m_motorTreeWidget = new QTreeWidget;
    m_motorTreeWidget->setHeaderHidden(true); 
    m_motorsRootItem = new QTreeWidgetItem(m_motorTreeWidget, {"Motors"});
    m_motorsRootItem->setFlags(m_motorsRootItem->flags() & ~Qt::ItemIsSelectable);
    m_motorsRootItem->setExpanded(true);
    motorLayout->addWidget(m_motorTreeWidget); 

    // 2번: +/- 버튼 추가
    QHBoxLayout* buttonLayout = new QHBoxLayout;
    m_addMotorButton = new QToolButton();
    m_addMotorButton->setText("+");
    m_removeMotorButton = new QToolButton();
    m_removeMotorButton->setText("-");
    buttonLayout->addStretch();
    buttonLayout->addWidget(m_addMotorButton);
    buttonLayout->addWidget(m_removeMotorButton);
    motorLayout->addLayout(buttonLayout); 

    leftDock->setWidget(motorListWidget); 
    addDockWidget(Qt::LeftDockWidgetArea, leftDock);

    connect(m_addMotorButton, &QToolButton::clicked, this, &MainWindow::onAddMotor);
    connect(m_removeMotorButton, &QToolButton::clicked, this, &MainWindow::onRemoveMotor);

    // 7. 우측 제약 조건 메뉴
    QDockWidget* rightDock = new QDockWidget("제약 조건 (활성 모터)", this);
    QWidget* constraintsWidget = new QWidget;
    QVBoxLayout* rightLayout = new QVBoxLayout(constraintsWidget);
    QFormLayout* formLayout = new QFormLayout; 
    
    m_yMinSpin = new QDoubleSpinBox;
    m_yMinSpin->setRange(-10000, 10000);
    formLayout->addRow("Y 최소값:", m_yMinSpin);
    m_yMaxSpin = new QDoubleSpinBox;
    m_yMaxSpin->setRange(-10000, 10000);
    formLayout->addRow("Y 최대값:", m_yMaxSpin);
    m_slopeSpin = new QDoubleSpinBox;
    m_slopeSpin->setRange(0, 100000);
    m_slopeSpin->setValue(1000.0); 
    formLayout->addRow("최대 기울기:", m_slopeSpin);
    rightLayout->addLayout(formLayout); 

    // 6번: Apply 버튼 추가
    m_applyConstraintsButton = new QPushButton("Apply Constraints");
    rightLayout->addWidget(m_applyConstraintsButton); 
    rightLayout->addStretch(); 
    
    rightDock->setWidget(constraintsWidget);
    addDockWidget(Qt::RightDockWidgetArea, rightDock);

    connect(m_applyConstraintsButton, &QPushButton::clicked, this, &MainWindow::onApplyConstraints);
}

// 8. 모터 트리에서 선택이 변경될 때
void MainWindow::onMotorSelectionChanged(QTreeWidgetItem* current, QTreeWidgetItem* previous) {
    Q_UNUSED(previous); 
    if (!current || current == m_motorsRootItem) {
        m_document->setActiveMotor(nullptr);
        return;
    }
    MotorProfile* profile = current->data(0, Qt::UserRole).value<MotorProfile*>();
    m_document->setActiveMotor(profile);
}

// 2번: 모터 추가 슬롯
void MainWindow::onAddMotor() {
    bool ok;
    QString name = QInputDialog::getText(this, "새 모터", "모터 이름:", QLineEdit::Normal, "New Motor", &ok);
    
    if (ok && !name.isEmpty()) {
        QColor color = QColor::fromHsv(qrand() % 360, 200, 200);
        m_document->addMotor(name, color);
        // modelChanged 시그널이 onDocumentModelChanged를 호출
    }
}

// 2번: 모터 제거 슬롯
void MainWindow::onRemoveMotor() {
    QTreeWidgetItem* currentItem = m_motorTreeWidget->currentItem();
    if (!currentItem || currentItem == m_motorsRootItem) return;
    
    MotorProfile* profile = currentItem->data(0, Qt::UserRole).value<MotorProfile*>();
    if (!profile) return;
    
    auto reply = QMessageBox::question(this, "모터 삭제",
        QString("'%1' 모터를 정말 삭제하시겠습니까?").arg(profile->name()),
        QMessageBox::Yes | QMessageBox::No);
        
    if (reply == QMessageBox::Yes) {
        m_document->removeMotor(profile);
        // modelChanged 시그널이 onDocumentModelChanged를 호출
    }
}

void MainWindow::onSaveDocument() {
    QString fileName = QFileDialog::getSaveFileName(this, "프로파일 저장", "", "모션 JSON 파일 (*.json)");
    if (fileName.isEmpty()) return;
    if (!m_document->saveToFile(fileName)) {
        QMessageBox::warning(this, "저장 실패", "파일을 저장하는 데 실패했습니다.");
    }
}

void MainWindow::onLoadDocument() {
    QString fileName = QFileDialog::getOpenFileName(this, "프로파일 불러오기", "", "모션 JSON 파일 (*.json)");
    if (fileName.isEmpty()) return;
    if (!m_document->loadFromFile(fileName)) {
        QMessageBox::warning(this, "불러오기 실패", "파일을 불러오는 데 실패했습니다.");
    }
    // loadFromFile이 modelChanged를 호출
}

// 3c. Fit to View 슬롯
void MainWindow::onFitToView() {
    m_view->fitToView();
}

// 6. 제약조건 적용
void MainWindow::onApplyConstraints() {
    MotorProfile* profile = m_document->activeProfile();
    if (profile) {
        profile->checkAllNodes();
        // checkAllNodes가 dataChanged를 emit하면 뷰가 갱신됨
    }
}

// 12. 불러오기/모터추가/삭제 등으로 모델이 완전히 변경되었을 때
void MainWindow::onDocumentModelChanged() {
    m_motorTreeWidget->blockSignals(true); 
    m_motorsRootItem->takeChildren(); // 루트 하위의 기존 아이템 모두 삭제
    
    QTreeWidgetItem* activeItem = nullptr;
    MotorProfile* activeProfile = m_document->activeProfile();

    for (MotorProfile* profile : m_document->motorProfiles()) {
        QTreeWidgetItem* item = new QTreeWidgetItem(m_motorsRootItem);
        item->setText(0, profile->name());
        item->setForeground(0, profile->color());
        item->setData(0, Qt::UserRole, QVariant::fromValue(profile));
        if (profile == activeProfile) {
            activeItem = item;
        }
    }
    
    if (activeItem) {
        m_motorTreeWidget->setCurrentItem(activeItem);
    } else if (m_motorsRootItem->childCount() > 0) {
        m_motorTreeWidget->setCurrentItem(m_motorsRootItem->child(0));
    }
    
    m_motorTreeWidget->blockSignals(false);
    
    // 현재 활성 프로파일에 맞춰 스핀박스 갱신
    onActiveMotorSwitched(m_document->activeProfile(), nullptr); 
    
    m_undoStack->clear(); 
}

// 8. 활성 모터가 변경될 때 (스핀박스 연결 및 뷰 조절)
void MainWindow::onActiveMotorSwitched(MotorProfile* active, MotorProfile* previous) {
    if (previous) {
        disconnectProfileFromSpinBoxes(previous);
    }
    if (active) {
        connectProfileToSpinBoxes(active);

        // 트리 위젯 동기화
        m_motorTreeWidget->blockSignals(true);
        for(int i=0; i < m_motorsRootItem->childCount(); ++i) {
            QTreeWidgetItem* item = m_motorsRootItem->child(i);
            MotorProfile* profile = item->data(0, Qt::UserRole).value<MotorProfile*>();
            if(profile == active) {
                m_motorTreeWidget->setCurrentItem(item);
                break;
            }
        }
        m_motorTreeWidget->blockSignals(false);
        
        // 1. (추가) 뷰가 새 활성 모터의 Y축에 맞게 줌/패닝하도록 명령
        m_view->fitToActiveMotor(active);
        
    } else {
        // 1. (추가) 활성 모터가 없으면 뷰 리셋
        m_view->fitToActiveMotor(nullptr);
    }
    
    m_undoStack->clear(); // 모터가 바뀌면 스택 비우기
}

// 7. 스핀박스 <-> 모델 연결 (static_cast로 통일)
void MainWindow::connectProfileToSpinBoxes(MotorProfile* profile) {
    if (!profile) return;
    
    m_yMinSpin->setValue(profile->yMin());
    m_yMaxSpin->setValue(profile->yMax());
    m_slopeSpin->setValue(profile->maxSlope());

    // qOverload 대신 static_cast를 사용해 모든 Qt 5 버전과 호환
    connect(m_yMinSpin, static_cast<void (QDoubleSpinBox::*)(double)>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setYMin);
    connect(m_yMaxSpin, static_cast<void (QDoubleSpinBox::*)(double)>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setYMax);
    connect(m_slopeSpin, static_cast<void (QDoubleSpinBox::*)(double)>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setMaxSlope);
}

// 7. 스핀박스 <-> 모델 연결 해제 (static_cast로 통일)
void MainWindow::disconnectProfileFromSpinBoxes(MotorProfile* profile) {
     if (!profile) return;
     disconnect(m_yMinSpin, static_cast<void (QDoubleSpinBox::*)(double)>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setYMin);
     disconnect(m_yMaxSpin, static_cast<void (QDoubleSpinBox::*)(double)>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setYMax);
     disconnect(m_slopeSpin, static_cast<void (QDoubleSpinBox::*)(double)>(&QDoubleSpinBox::valueChanged), profile, &MotorProfile::setMaxSlope);
}


// --- 4. Export 다이얼로그 로직 (JSON으로 내보내도록 수정) ---
void MainWindow::onExportDocument() {
    if (!m_document || !m_document->activeProfile()) {
        QMessageBox::warning(this, "내보내기 오류", "선택된 모터가 없습니다.");
        return;
    }

    // 1. 다이얼로그 생성
    QDialog dialog(this);
    dialog.setWindowTitle("프로파일 내보내기");
    QVBoxLayout layout(&dialog);
    
    QRadioButton* nodesOnlyRadio = new QRadioButton("노드만 내보내기 (이 파일만)");
    QRadioButton* sampledRadio = new QRadioButton("샘플링하여 내보내기 (이 파일만)");
    QRadioButton* allNodesRadio = new QRadioButton("모든 모터의 노드 내보내기 (Save와 동일)");
    
    nodesOnlyRadio->setChecked(true);
    layout.addWidget(nodesOnlyRadio);
    layout.addWidget(sampledRadio);
    layout.addWidget(allNodesRadio);

    // 샘플링 옵션용 위젯 (평소엔 숨김)
    QWidget* optionsWidget = new QWidget;
    QFormLayout* optionsLayout = new QFormLayout(optionsWidget);
    QDoubleSpinBox* endTimeSpin = new QDoubleSpinBox;
    endTimeSpin->setRange(0.0, 10000.0); // 0초부터
    endTimeSpin->setValue(2.0); // 기본값
    if (!m_document->activeProfile()->nodes().isEmpty()) {
        endTimeSpin->setValue(m_document->activeProfile()->nodes().last().x());
    }
    endTimeSpin->setSuffix(" s");
    QSpinBox* hzSpin = new QSpinBox;
    hzSpin->setRange(1, 10000);
    hzSpin->setValue(100);
    hzSpin->setSuffix(" Hz");
    optionsLayout->addRow("종료 시간:", endTimeSpin);
    optionsLayout->addRow("샘플링 속도:", hzSpin);
    optionsWidget->setVisible(false);
    layout.addWidget(optionsWidget);

    connect(sampledRadio, &QRadioButton::toggled, optionsWidget, &QWidget::setVisible);

    QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
    layout.addWidget(buttonBox);
    connect(buttonBox, &QDialogButtonBox::accepted, &dialog, &QDialog::accept);
    connect(buttonBox, &QDialogButtonBox::rejected, &dialog, &QDialog::reject);

    // 2. 다이얼로그 실행
    if (dialog.exec() != QDialog::Accepted) {
        return;
    }

    // 3. 파일 경로 묻기
    QString fileName = QFileDialog::getSaveFileName(this, "내보내기", "", "JSON 파일 (*.json)");
    if (fileName.isEmpty()) return;

    QFile file(fileName);
    if (!file.open(QIODevice::WriteOnly)) {
        QMessageBox::warning(this, "파일 오류", "파일을 열 수 없습니다.");
        return;
    }
    
    // 4. 선택된 옵션에 따라 JSON 객체 생성
    QJsonObject rootObj;
    QJsonArray motorsArray;
    MotorProfile* activeProfile = m_document->activeProfile();

    if (allNodesRadio->isChecked()) {
        // "Save"와 동일하게 모든 모터의 "노드"를 저장
        for (MotorProfile* profile : m_document->motorProfiles()) {
            QJsonObject motorObj;
            profile->write(motorObj);
            motorsArray.append(motorObj);
        }
    } else if (nodesOnlyRadio->isChecked()) {
        // 활성 모터의 "노드"만 저장
        QJsonObject motorObj;
        activeProfile->write(motorObj);
        motorsArray.append(motorObj);
    } else {
        // 활성 모터의 "샘플링" 데이터만 저장
        QJsonObject motorObj;
        activeProfile->exportSamplesToJSON(motorObj, hzSpin->value(), endTimeSpin->value());
        motorsArray.append(motorObj);
    }
    
    rootObj["motors"] = motorsArray;
    
    // 4번: JSON 파일로 저장
    file.write(QJsonDocument(rootObj).toJson());
    file.close();
    
    statusBar()->showMessage("내보내기 완료.", 2000);
}

