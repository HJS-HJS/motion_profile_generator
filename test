네, 요청하신 모든 기능(Undo/Redo, Export, 편집 편의 기능)과 이전의 수정 사항들을 모두 통합한 C++/Qt 5 프로젝트의 전체 코드를 다시 작성해 드립니다.
프로젝트가 커져서 10개였던 파일이 총 12개가 되었습니다. commands.h와 commands.cpp 파일이 Undo/Redo 기능을 위해 추가되었습니다.
1. 프로젝트 파일 구조
MotionEditor_Qt5_v2 폴더를 만드시고, 그 안에 다음 12개의 파일을 생성하세요.
MotionEditor_Qt5_v2/
├── CMakeLists.txt         # 1. 빌드 스크립트 (Qt 5)
├── main.cpp               # 2. 애플리케이션 진입점
├── commands.h             # 3. [신규] Undo/Redo 커맨드 헤더
├── commands.cpp           # 4. [신규] Undo/Redo 커맨드 구현
├── motionmodels.h         # 5. [수정] 데이터 모델 (내부 함수, 보간 함수 추가)
├── motionmodels.cpp       # 6. [수정] 데이터 모델 (커맨드용 로직, Export 로직)
├── graphnodeitem.h        # 7. [수정] 노드 아이템 (Undo/Redo 스택 포인터)
├── graphnodeitem.cpp      # 8. [수정] 노드 아이템 (커맨드 생성, 스냅)
├── grapheditorview.h      # 9. [수정] 뷰 (Delete키, 스냅, Fit 기능)
├── grapheditorview.cpp    # 10. [수정] 뷰 (기능 구현)
├── mainwindow.h           # 11. [수정] 메인 윈도우 (Undo/Redo, Export 메뉴)
└── mainwindow.cpp         # 12. [수정] 메인 윈도우 (UI, Export 다이얼로그)

2. 전체 소스 코드
1. CMakeLists.txt (변경 없음)
(이전과 동일한 Qt 5 빌드 스크립트)
cmake_minimum_required(VERSION 3.16)
project(MotionEditor_Qt5_v2 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(Qt5 REQUIRED COMPONENTS Core Gui Widgets)

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_INCLUDE_CURRENT_DIR ON)

# 실행 파일 생성 (commands.cpp, commands.h 추가)
add_executable(MotionEditor
    main.cpp
    mainwindow.h
    mainwindow.cpp
    motionmodels.h
    motionmodels.cpp
    grapheditorview.h
    grapheditorview.cpp
    graphnodeitem.h
    graphnodeitem.cpp
    commands.h
    commands.cpp
)

target_link_libraries(MotionEditor PRIVATE
    Qt5::Core
    Qt5::Gui
    Qt5::Widgets
)

2. main.cpp (변경 없음)
#include "mainwindow.h"
#include <QApplication>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    return a.exec();
}

3. commands.h (신규 파일)
Undo/Redo 기능을 위한 커맨드 클래스들을 정의합니다.
#pragma once

#include <QUndoCommand>
#include <QPointF>
#include "motionmodels.h" // MotionNode, MotorProfile 사용

// 1. 노드 추가 커맨드
class AddNodeCommand : public QUndoCommand {
public:
    AddNodeCommand(MotorProfile* profile, const MotionNode& node, QUndoCommand* parent = nullptr);
    void undo() override;
    void redo() override;
private:
    MotorProfile* m_profile;
    MotionNode m_node;
    int m_nodeIndex; // undo를 위해 추가된 인덱스 저장
};

// 2. 노드 삭제 커맨드
class DeleteNodeCommand : public QUndoCommand {
public:
    DeleteNodeCommand(MotorProfile* profile, int index, QUndoCommand* parent = nullptr);
    void undo() override;
    void redo() override;
private:
    MotorProfile* m_profile;
    MotionNode m_node; // 복원을 위한 노드 데이터
    int m_nodeIndex;
};

// 3. 노드 이동 커맨드
class MoveNodeCommand : public QUndoCommand {
public:
    MoveNodeCommand(MotorProfile* profile, int index, const QPointF& oldPos, const QPointF& newPos, QUndoCommand* parent = nullptr);
    void undo() override;
    void redo() override;
    // 여러 개의 이동을 하나로 합치기 위한 함수 (드래그 시 유용)
    bool mergeWith(const QUndoCommand* command) override;
    int id() const override { return 1234; } // 병합을 위한 ID

private:
    MotorProfile* m_profile;
    int m_nodeIndex;
    QPointF m_oldPos;
    QPointF m_newPos;
};

4. commands.cpp (신규 파일)
커맨드 클래스들의 로직을 구현합니다.
#include "commands.h"
#include <QDebug>

// --- AddNodeCommand ---
AddNodeCommand::AddNodeCommand(MotorProfile* profile, const MotionNode& node, QUndoCommand* parent)
    : QUndoCommand(parent), m_profile(profile), m_node(node), m_nodeIndex(-1) {
    setText("노드 추가");
}

void AddNodeCommand::redo() {
    m_nodeIndex = m_profile->internalAddNode(m_node); // 내부 함수 호출
    m_profile->sortNodes(); // 정렬
    m_profile->emitDataChanged(); // 뷰 갱신
}

void AddNodeCommand::undo() {
    if (m_nodeIndex != -1) {
        m_profile->internalRemoveNode(m_nodeIndex); // 내부 함수 호출
        // sortNodes()는 필요 없음
        m_profile->emitDataChanged(); // 뷰 갱신
    }
}

// --- DeleteNodeCommand ---
DeleteNodeCommand::DeleteNodeCommand(MotorProfile* profile, int index, QUndoCommand* parent)
    : QUndoCommand(parent), m_profile(profile), m_nodeIndex(index) {
    m_node = m_profile->nodeAt(index); // 삭제 전 노드 정보 백업
    setText("노드 삭제");
}

void DeleteNodeCommand::redo() {
    m_profile->internalRemoveNode(m_nodeIndex);
    m_profile->emitDataChanged();
}

void DeleteNodeCommand::undo() {
    m_profile->internalAddNode(m_node); // 삭제했던 노드 복원
    m_profile->sortNodes();
    m_profile->emitDataChanged();
}


// --- MoveNodeCommand ---
MoveNodeCommand::MoveNodeCommand(MotorProfile* profile, int index, const QPointF& oldPos, const QPointF& newPos, QUndoCommand* parent)
    : QUndoCommand(parent), m_profile(profile), m_nodeIndex(index), m_oldPos(oldPos), m_newPos(newPos) {
    setText("노드 이동");
}

void MoveNodeCommand::redo() {
    m_profile->internalMoveNode(m_nodeIndex, m_newPos);
    m_profile->sortNodes();
    m_profile->emitDataChanged();
}

void MoveNodeCommand::undo() {
    m_profile->internalMoveNode(m_nodeIndex, m_oldPos);
    m_profile->sortNodes();
    m_profile->emitDataChanged();
}

// 드래그 중 발생하는 수많은 이동 커맨드를 하나로 합칩니다.
bool MoveNodeCommand::mergeWith(const QUndoCommand* command) {
    const MoveNodeCommand* moveCommand = static_cast<const MoveNodeCommand*>(command);
    if (moveCommand->m_nodeIndex != m_nodeIndex) {
        return false;
    }
    m_newPos = moveCommand->m_newPos; // 최종 위치만 갱신
    return true;
}

5. motionmodels.h (수정됨)
Undo/Redo를 위한 내부 함수, Export를 위한 sampleAt 함수 추가.
#pragma once
// ... (includes) ...
#include <QTextStream> // Export용

// ... (MotionNode definition) ...

class MotorProfile : public QObject {
    // ... (Q_OBJECT, Q_PROPERTY) ...
public:
    // ... (생성자, Getters) ...
    int nodeCount() const { return m_nodes.size(); }
    MotionNode nodeAt(int index) const;

    // Export를 위한 선형 보간 함수
    double sampleAt(double time) const;

    // JSON 직렬화/역직렬화
    void read(const QJsonObject& json);
    void write(QJsonObject& json) const;

    // --- Undo/Redo를 위한 공개 내부 함수 ---
    int internalAddNode(const MotionNode& node);
    void internalRemoveNode(int index);
    void internalMoveNode(int index, const MotionNode& pos);
    void sortNodes(); // 커맨드가 호출할 수 있도록 공개
    void emitDataChanged(); // 커맨드가 호출할 수 있도록 공개

public slots:
    // 7. 제약 조건 Setters
    void setYMin(double val);
    void setYMax(double val);
    void setMaxSlope(double val);

    // 6. 제약조건 적용 슬롯 (이전과 동일)
    void checkAllNodes(); 

    // --- 이 함수들은 이제 커맨드를 생성하는 UI가 대체합니다 ---
    // bool addNode(const MotionNode& node);
    // bool updateNode(int index, const MotionNode& node);
    // void deleteNode(int index);

signals:
    void dataChanged();
    void constraintsChanged();

private:
    bool isNodeValid(const MotionNode& node, int indexToIgnore) const;
    // void sortNodes(); // 비공개 -> 공개로 이동

    // ... (m_name, m_color, m_nodes, ...) ...
};

class MotionDocument : public QObject {
    // ... (Q_OBJECT) ...
public:
    // ... (생성자, 소멸자, Getters) ...

    // Export 로직
    bool exportNodesToStream(QTextStream& stream) const;
    bool exportSamplesToStream(QTextStream& stream, double sampleRateHz, double endTimeSec) const;

public slots:
    MotorProfile* addMotor(const QString& name, QColor color);
    void setActiveMotor(MotorProfile* profile); 
    void removeMotor(MotorProfile* profile);
    bool saveToFile(const QString& filename) const;
    bool loadFromFile(const QString& filename);

signals:
    // ... (기존과 동일)
private:
    // ... (기존과 동일)
};

Q_DECLARE_METATYPE(MotorProfile*)

6. motionmodels.cpp (수정됨)
Undo/Redo용 내부 함수, Export 로직, 파일 읽기/쓰기 수정.
#include "motionmodels.h"
// ... (includes) ...
#include <qmath.h> // qBound, qFloor

// --- MotorProfile 구현 ---
// ... (생성자, nodeAt, Setters ... ) ...

// 6. 제약조건 적용 (이전과 동일)
void MotorProfile::checkAllNodes() {
    bool dataWasChanged = false;
    for (int i = 0; i < m_nodes.size(); ++i) {
        MotionNode node = m_nodes[i];
        double oldY = node.y();
        double clampedY = qBound(m_y_min, oldY, m_y_max);
        
        if (oldY != clampedY) {
            node.setY(clampedY);
            m_nodes[i] = node;
            dataWasChanged = true;
        }
    }
    if (dataWasChanged) {
        sortNodes();
        emit dataChanged();
    }
}

// Export용 선형 보간 함수
double MotorProfile::sampleAt(double time) const {
    if (m_nodes.isEmpty()) return 0.0;
    
    // 1. 시간보다 이전 노드 찾기
    const MotionNode* prev = nullptr;
    const MotionNode* next = nullptr;
    
    for (int i = 0; i < m_nodes.size(); ++i) {
        if (m_nodes[i].x() <= time) {
            prev = &m_nodes[i];
        } else {
            next = &m_nodes[i];
            break;
        }
    }
    
    // 2. 엣지 케이스 처리
    if (!prev) return m_nodes.first().y(); // 시간 0 이전 -> 첫 번째 노드 값
    if (!next) return m_nodes.last().y();  // 마지막 노드 이후 -> 마지막 노드 값

    // 3. 선형 보간
    if (qAbs(next->x() - prev->x()) < 1e-6) {
        return prev->y(); // 두 노드가 같은 시간
    }
    
    double t = (time - prev->x()) / (next->x() - prev->x());
    return prev->y() * (1.0 - t) + next->y() * t;
}

// 4. 파일 쓰기 (이름, 노드만) - (이전과 동일)
void MotorProfile::write(QJsonObject& json) const {
    json["name"] = m_name;
    QJsonArray nodesArray;
    for (const MotionNode& node : m_nodes) {
        QJsonObject nodeObj;
        nodeObj["time"] = node.x();
        nodeObj["value"] = node.y();
        nodesArray.append(nodeObj);
    }
    json["nodes"] = nodesArray;
}
void MotorProfile::read(const QJsonObject& json) { ... } // (이전과 동일)
bool MotorProfile::isNodeValid(...) const { ... } // (이전과 동일)

// --- Undo/Redo용 내부 함수 ---
int MotorProfile::internalAddNode(const MotionNode& node) {
    m_nodes.append(node);
    // 추가된 노드의 실제 인덱스를 찾기 위해 정렬이 필요하지만,
    // 정렬은 커맨드의 redo()에서 하므로 여기서는 일단 마지막 인덱스를 반환 (redo에서 수정됨)
    // -> 수정: AddNodeCommand에서 인덱스를 찾아야 함.
    sortNodes();
    return m_nodes.indexOf(node);
}
void MotorProfile::internalRemoveNode(int index) {
    if (index >= 0 && index < m_nodes.size()) {
        m_nodes.remove(index);
    }
}
void MotorProfile::internalMoveNode(int index, const MotionNode& pos) {
    if (index >= 0 && index < m_nodes.size()) {
        m_nodes[index] = pos;
    }
}
void MotorProfile::sortNodes() {
    std::sort(m_nodes.begin(), m_nodes.end(), [](const MotionNode& a, const MotionNode& b) {
        return a.x() < b.x();
    });
}
void MotorProfile::emitDataChanged() {
    emit dataChanged();
}

// --- MotionDocument 구현 ---
// ... (생성자, 소멸자, Getters, addMotor, setActiveMotor, removeMotor ... ) ...
// (파일 읽기/쓰기 수정)
bool MotionDocument::saveToFile(...) const { ... } // (이전과 동일)
bool MotionDocument::loadFromFile(const QString& filename) { // (이전과 동일)
    // ...
    // (이전과 동일한 로직)
    for (const QJsonValue& val : motorsArray) {
        QJsonObject motorObj = val.toObject();
        MotorProfile* profile = new MotorProfile("", Qt::black, this); 
        profile->read(motorObj);
        m_profiles.append(profile);
        emit motorAdded(profile); 
    }
    emit modelChanged(); 
    if (!m_profiles.isEmpty()) {
        setActiveMotor(m_profiles.first());
    }
    return true;
}

// --- Export 로직 ---
bool MotionDocument::exportNodesToStream(QTextStream& stream) const {
    if (!m_activeProfile) return false;
    
    stream << "Motor: " << m_activeProfile->name() << "\n";
    stream << "Time (s),Value\n";
    for (const MotionNode& node : m_activeProfile->nodes()) {
        stream << node.x() << "," << node.y() << "\n";
    }
    return true;
}

bool MotionDocument::exportSamplesToStream(QTextStream& stream, double sampleRateHz, double endTimeSec) const {
    if (!m_activeProfile || sampleRateHz <= 0 || endTimeSec <= 0) return false;

    stream << "Motor: " << m_activeProfile->name() << "\n";
    stream << "SampleRate: " << sampleRateHz << " Hz\n";
    stream << "Time (s),Value\n";
    
    double dt = 1.0 / sampleRateHz;
    for (double time = 0.0; time <= endTimeSec; time += dt) {
        double value = m_activeProfile->sampleAt(time);
        stream << time << "," << value << "\n";
    }
    // 마지막 샘플 포함 보장
    double value = m_activeProfile->sampleAt(endTimeSec);
    stream << endTimeSec << "," << value << "\n";
    
    return true;
}

7. graphnodeitem.h (수정됨)
Undo 스택과 뷰 포인터를 받도록 생성자 수정.
#pragma once
// ... (includes) ...

class MotorProfile;
class GraphEditorView; // 뷰 포인터 (스냅용)
class QUndoStack; // Undo 스택 포인터

class GraphNodeItem : public QObject, public QGraphicsEllipseItem {
    Q_OBJECT
public:
    // 생성자 수정
    GraphNodeItem(MotorProfile* profile, int index, 
                  GraphEditorView* view, QUndoStack* stack, 
                  QGraphicsItem* parent = nullptr);
    
    MotorProfile* profile() const { return m_profile; }
    int index() const { return m_nodeIndex; }
    void setNodeIndex(int index) { m_nodeIndex = index; } // 인덱스 변경 시 필요

protected:
    void contextMenuEvent(QGraphicsSceneContextMenuEvent *event) override;
    void mousePressEvent(QGraphicsSceneMouseEvent* event) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent* event) override;
    QVariant itemChange(GraphicsItemChange change, const QVariant& value) override;

private slots:
    void onEditTriggered();  
    void onDeleteTriggered();

private:
    MotorProfile* m_profile;
    int m_nodeIndex;
    QPointF m_dragStartPosition;
    
    GraphEditorView* m_view; // 스냅 기능용
    QUndoStack* m_undoStack; // Undo/Redo용
};

8. graphnodeitem.cpp (수정됨)
모든 수정 로직이 QUndoCommand를 생성하도록 변경. 스냅 기능 추가.
#include "graphnodeitem.h"
#include "grapheditorview.h" // 스냅 기능
#include "commands.h" // 커맨드
#include <QUndoStack> // Undo 스택
// ... (includes) ...

// 생성자 수정
GraphNodeItem::GraphNodeItem(MotorProfile* profile, int index, 
                             GraphEditorView* view, QUndoStack* stack, 
                             QGraphicsItem* parent)
    : QObject(nullptr), QGraphicsEllipseItem(parent), 
      m_profile(profile), m_nodeIndex(index), 
      m_view(view), m_undoStack(stack)
{
    // ... (setRect, setPen, setBrush, setFlag ... 기존과 동일)
    setFlag(QGraphicsItem::ItemIsSelectable); // Delete 키를 위해 추가
    setPos(m_profile->nodeAt(m_nodeIndex));
}

// 1. 좌클릭 드래그 시작 (이전과 동일)
void GraphNodeItem::mousePressEvent(QGraphicsSceneMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        m_dragStartPosition = pos(); 
    }
    QGraphicsEllipseItem::mousePressEvent(event);
}

// 1. 좌클릭 드래그 종료 -> MoveNodeCommand 생성
void GraphNodeItem::mouseReleaseEvent(QGraphicsSceneMouseEvent* event) {
    QGraphicsEllipseItem::mouseReleaseEvent(event);
    
    if (event->button() == Qt::LeftButton && pos() != m_dragStartPosition) {
        // m_profile->updateNode(...) 대신 커맨드 사용
        m_undoStack->push(new MoveNodeCommand(m_profile, m_nodeIndex, m_dragStartPosition, pos()));
    }
}

// 우클릭 메뉴
void GraphNodeItem::contextMenuEvent(QGraphicsSceneContextMenuEvent *event) {
    // ... (이전과 동일)
}

// 스냅 기능 추가 (Feature 3b)
QVariant GraphNodeItem::itemChange(GraphicsItemChange change, const QVariant& value) {
    if (change == ItemPositionChange && scene()) {
        QPointF newPos = value.toPointF();

        // 1. 스냅 기능
        if (m_view && m_view->isSnapEnabled()) {
            double gridSize = m_view->gridSize();
            newPos.setX(qRound(newPos.x() / gridSize) * gridSize);
            newPos.setY(qRound(newPos.y() / gridSize) * gridSize);
        }

        // 2. Y축 제한
        double clampedY = qBound(m_profile->yMin(), newPos.y(), m_profile->yMax());
        newPos.setY(clampedY);
        
        return newPos;
    }
    return QGraphicsItem::itemChange(change, value);
}

// 7. 좌표 동시 편집 -> MoveNodeCommand 생성
void GraphNodeItem::onEditTriggered() {
    MotionNode currentNode = m_profile->nodeAt(m_nodeIndex);
    // ... (QDialog, QFormLayout, ... 기존과 동일) ...
    if (dialog.exec() == QDialog::Accepted) {
        double newTime = xSpin->value();
        double newValue = ySpin->value();
        // m_profile->updateNode(...) 대신 커맨드 사용
        m_undoStack->push(new MoveNodeCommand(m_profile, m_nodeIndex, currentNode, QPointF(newTime, newValue)));
    }
}

// 5. 노드 삭제 -> DeleteNodeCommand 생성
void GraphNodeItem::onDeleteTriggered() {
    // m_profile->deleteNode(...) 대신 커맨드 사용
    m_undoStack->push(new DeleteNodeCommand(m_profile, m_nodeIndex));
}

9. grapheditorview.h (수정됨)
Undo 스택, 스냅, Delete키, Fit 기능 추가.
#pragma once
// ... (includes) ...
#include <qmath.h>

class QUndoStack; // Undo 스택
class QKeyEvent; // Delete 키

class GraphEditorView : public QGraphicsView {
    Q_OBJECT
public:
    explicit GraphEditorView(QWidget* parent = nullptr);
    void setDocument(MotionDocument* doc);
    
    // MainWindow가 스택을 전달하기 위한 함수
    void setUndoStack(QUndoStack* stack) { m_undoStack = stack; }
    
    // 스냅 기능용
    bool isSnapEnabled() const { return m_snapToGrid; }
    double gridSize() const { return m_gridSize; }

public slots:
    void fitToView(); // Fit 기능 슬롯
    void toggleSnapToGrid(bool checked) { m_snapToGrid = checked; }

protected:
    // ... (wheelEvent, mousePressEvent, ...) ...
    void contextMenuEvent(QContextMenuEvent* event) override;
    
    // Delete 키 (Feature 3a)
    void keyPressEvent(QKeyEvent* event) override; 

    void drawBackground(QPainter* painter, const QRectF& rect) override;

private slots:
    // ... (onDocumentCleared, onMotorAdded, onActiveMotorChanged, ...) ...
    void onProfileDataChanged(); // 수정됨
    // ... (onProfileConstraintsChanged, updateConstraintItems) ...

private:
    // ... (rebuildProfileItems, updateProfileVisibility, ...) ...
    // ... (m_constraintItems, setConstraintItemsVisible) ...

    QUndoStack* m_undoStack = nullptr; // Undo 스택
    
    // 스냅 기능 (Feature 3b)
    bool m_snapToGrid = false;
    double m_gridSize = 10.0;
    
    QGraphicsScene* m_scene;
    // ... (m_document, m_profileItems, m_isPanning, m_panStartPos) ...
};

10. grapheditorview.cpp (수정됨)
Delete키, Fit, 스냅, Undo 기능 구현.
#include "grapheditorview.h"
#include "commands.h" // 커맨드
#include <QUndoStack> // Undo 스택
#include <QKeyEvent> // Delete 키
// ... (includes) ...

GraphEditorView::GraphEditorView(QWidget* parent)
    : QGraphicsView(parent), m_scene(new QGraphicsScene(this)), m_isPanning(false)
{
    // ... (기존 생성자 코드) ...
    // Delete 키를 받기 위해 포커스 정책 설정
    setFocusPolicy(Qt::StrongFocus);
}

void GraphEditorView::setDocument(MotionDocument* doc) { ... } // (이전과 동일)

// --- 이벤트 오버라이드 ---
void GraphEditorView::wheelEvent(QWheelEvent* event) { ... } // (이전과 동일)
void GraphEditorView::mousePressEvent(QMouseEvent* event) { ... } // (이전과 동일)
void GraphEditorView::mouseReleaseEvent(QMouseEvent* event) { ... } // (이전과 동일)
void GraphEditorView::mouseMoveEvent(QMouseEvent* event) { ... } // (이전과 동일)

// 2. 우클릭 -> AddNodeCommand 생성
void GraphEditorView::contextMenuEvent(QContextMenuEvent* event) {
    if (!m_document || !m_document->activeProfile() || !m_undoStack) return;
    // ... (scenePos, activeProfile, menu, addAction ... 기존과 동일) ...
    connect(addAction, &QAction::triggered, this, [=]() {
        // m_profile->addNode(...) 대신 커맨드 사용
        m_undoStack->push(new AddNodeCommand(activeProfile, scenePos));
    });
    menu.exec(event->globalPos());
}

// 3a. Delete 키 구현
void GraphEditorView::keyPressEvent(QKeyEvent* event) {
    if (event->key() == Qt::Key_Delete) {
        if (!m_document || !m_document->activeProfile() || !m_undoStack) return;

        QList<GraphNodeItem*> itemsToDelete;
        for (QGraphicsItem* item : m_scene->selectedItems()) {
            if (auto nodeItem = qgraphicsitem_cast<GraphNodeItem*>(item)) {
                itemsToDelete.append(nodeItem);
            }
        }
        
        if (itemsToDelete.isEmpty()) return;

        // 인덱스 꼬임 방지: 뒤쪽(높은 인덱스)부터 삭제
        std::sort(itemsToDelete.begin(), itemsToDelete.end(), [](auto a, auto b) {
            return a->index() > b->index();
        });

        m_undoStack->beginMacro("선택된 노드 삭제");
        for (GraphNodeItem* item : itemsToDelete) {
            m_undoStack->push(new DeleteNodeCommand(item->profile(), item->index()));
        }
        m_undoStack->endMacro();
        
        event->accept();
    } else {
        QGraphicsView::keyPressEvent(event);
    }
}

void GraphEditorView::drawBackground(QPainter* painter, const QRectF& rect) { ... } // (이전과 동일)

// --- 슬롯 구현 ---
void GraphEditorView::onDocumentCleared() { ... } // (이전과 동일)
void GraphEditorView::clearAllProfileItems() { ... } // (이전과 동일)
void GraphEditorView::onMotorAdded(MotorProfile* profile) {
    // ... (m_profileItems.insert, rebuildProfileItems, ... 기존과 동일) ...
    connect(profile, &MotorProfile::dataChanged, this, &GraphEditorView::onProfileDataChanged);
    connect(profile, &MotorProfile::constraintsChanged, this, &GraphEditorView::updateConstraintItems);
}
void GraphEditorView::onActiveMotorChanged(...) { ... } // (이전과 동일)

// 데이터 변경 시 (Undo/Redo 포함)
void GraphEditorView::onProfileDataChanged() {
    MotorProfile* profile = qobject_cast<MotorProfile*>(sender());
    if (profile) {
        // rebuildProfileItems가 m_profile->nodeAt(i)를 사용하는데,
        // 이 때 인덱스가 바뀔 수 있음. GraphNodeItem의 인덱스도 갱신해야 함.
        // -> rebuildProfileItems에서 GraphNodeItem을 새로 만들므로
        //    인덱스는 자동으로 갱신됨.
        rebuildProfileItems(profile);
        updateProfileVisibility(profile, (profile == m_document->activeProfile()));
    }
}

void GraphEditorView::onProfileConstraintsChanged() { ... } // (이전과 동일)

// 1, 3, 4. 프로파일 다시 그리기 (GraphNodeItem 생성자 수정)
void GraphEditorView::rebuildProfileItems(MotorProfile* profile) {
    // ... (기존 삭제 로직) ...
    
    // ... (선 그리기 로직) ...

    // 5. 노드 그리기 (생성자 인자 추가)
    for (int i = 0; i < nodes.size(); ++i) {
        GraphNodeItem* nodeItem = new GraphNodeItem(profile, i, this, m_undoStack); // view, stack 전달
        m_scene->addItem(nodeItem);
        items.append(nodeItem);
    }
}

void GraphEditorView::updateProfileVisibility(...) { ... } // (이전과 동일)
void GraphEditorView::updateConstraintItems(MotorProfile* profile) {
    // ... (기존 삭제 로직) ...
    // ... (라인, 텍스트 생성 로직) ...
    
    // 1. (수정) 상한/하한선 굵게
    QPen linePen(color, 3, Qt::SolidLine); // 굵기 3, 실선
    
    // ... (minLine, maxLine 생성) ...
}
void GraphEditorView::setConstraintItemsVisible(...) { ... } // (이전과 동일)

// 3c. Fit to View 슬롯
void GraphEditorView::fitToView() {
    if (m_scene->items().isEmpty()) {
        return;
    }
    
    // itemsBoundingRect()는 모든 아이템(노드, 선, 축 라인)을 포함하는 영역
    QRectF bounds = m_scene->itemsBoundingRect();
    if (bounds.isValid()) {
        // 약간의 여백(padding)을 줌
        fitInView(bounds, Qt::KeepAspectRatio);
    }
}

11. mainwindow.h (수정됨)
Undo/Redo, Export, Snap, Fit 액션/메뉴 추가.
#pragma once
// ... (includes) ...

// ... (전방 선언) ...
class QToolButton;
class QPushButton;
class QUndoStack; // Undo 스택
class QUndoView; // (선택적) Undo 히스토리 뷰
class QAction;

class MainWindow : public QMainWindow {
    Q_OBJECT
public:
    MainWindow(QWidget* parent = nullptr);
    ~MainWindow();

private slots:
    // ... (onMotorSelectionChanged, onAddMotor, onRemoveMotor) ...
    void onSaveDocument();
    void onLoadDocument();
    
    // 신규 슬롯
    void onExportDocument(); // Export 다이얼로그
    void onFitToView();      // Fit to View

    // ... (onApplyConstraints, onDocumentModelChanged, onActiveMotorSwitched) ...

private:
    void createActions();
    void createMenus();
    void createDocks();
    
    // ... (connect/disconnectSpinBoxes) ...

    MotionDocument* m_document;
    GraphEditorView* m_view;

    QUndoStack* m_undoStack; // Undo 스택
    
    // ... (m_motorTreeWidget, m_motorsRootItem, m_add/removeMotorButton) ...
    // ... (m_yMinSpin, m_yMaxSpin, m_slopeSpin, m_applyConstraintsButton) ...
    
    // 메뉴 액션
    QAction* m_saveAction;
    QAction* m_loadAction;
    QAction* m_exportAction; // Export
    
    QAction* m_undoAction;   // Undo
    QAction* m_redoAction;   // Redo
    
    QAction* m_fitToViewAction; // Fit
    QAction* m_snapGridAction;  // Snap
};

12. mainwindow.cpp (수정됨)
Undo/Redo 스택 생성, Export 다이얼로그 구현.
#include "mainwindow.h"
#include "motionmodels.h"
#include "grapheditorview.h"

// ... (includes) ...
#include <QUndoStack> // Undo 스택
#include <QSpinBox> // Export 다이얼로그용
#include <QRadioButton> // Export 다이얼로그용
#include <QDialogButtonBox> // Export 다이얼로그용
#include <QTextStream> // Export용
// ...

MainWindow::MainWindow(QWidget* parent)
    : QMainWindow(parent)
{
    // 0. Undo 스택 생성 (가장 먼저)
    m_undoStack = new QUndoStack(this);

    // 1. 모델(데이터) 생성
    m_document = new MotionDocument(this);

    // 1. 뷰(그래프) 생성 및 설정
    m_view = new GraphEditorView(this);
    m_view->setDocument(m_document);
    m_view->setUndoStack(m_undoStack); // 뷰에 Undo 스택 전달
    setCentralWidget(m_view); 

    createActions();
    createMenus();
    createDocks(); 
    
    // ... (시그널 연결) ...
    // Fit, Snap 액션 연결
    connect(m_fitToViewAction, &QAction::triggered, m_view, &GraphEditorView::fitToView);
    connect(m_snapGridAction, &QAction::toggled, m_view, &GraphEditorView::toggleSnapToGrid);
    
    // ... (초기 모터 추가) ...
    
    // ... (첫 번째 모터 활성화) ...

    // 초기화 후 Undo 스택 비우기 (테스트 모터 추가는 Undo 불가)
    m_undoStack->clear(); 
}

MainWindow::~MainWindow() {
    // m_document, m_view, m_undoStack 등은 this의 자식이므로 자동 삭제
}

void MainWindow::createActions() {
    // ... (m_saveAction, m_loadAction) ...

    // Export 액션
    m_exportAction = new QAction("내보내기 (&E)...", this);
    connect(m_exportAction, &QAction::triggered, this, &MainWindow::onExportDocument);

    // Undo/Redo 액션
    m_undoAction = m_undoStack->createUndoAction(this, "실행 취소 (&U)");
    m_undoAction->setShortcut(QKeySequence::Undo);
    m_redoAction = m_undoStack->createRedoAction(this, "다시 실행 (&R)");
    m_redoAction->setShortcut(QKeySequence::Redo);

    // 뷰 액션
    m_fitToViewAction = new QAction("전체 보기 (&F)", this);
    m_fitToViewAction->setShortcut(Qt::Key_F);
    
    m_snapGridAction = new QAction("그리드에 맞추기 (&G)", this);
    m_snapGridAction->setCheckable(true);
    m_snapGridAction->setShortcut(Qt::Key_G);
}

void MainWindow::createMenus() {
    QMenu* fileMenu = menuBar()->addMenu("파일 (&F)");
    fileMenu->addAction(m_loadAction);
    fileMenu->addAction(m_saveAction);
    fileMenu->addAction(m_exportAction); // Export 메뉴 추가
    
    QMenu* editMenu = menuBar()->addMenu("편집 (&E)");
    editMenu->addAction(m_undoAction); // Undo
    editMenu->addAction(m_redoAction); // Redo
    editMenu->addSeparator();
    editMenu->addAction(m_snapGridAction); // Snap
    
    QMenu* viewMenu = menuBar()->addMenu("보기 (&V)");
    viewMenu->addAction(m_fitToViewAction); // Fit
}

void MainWindow::createDocks() { ... } // (이전과 동일)
void MainWindow::onMotorSelectionChanged(...) { ... } // (이전과 동일)
void MainWindow::onAddMotor() {
    // ... (이름 입력)
    if (ok && !name.isEmpty()) {
        // ... (색상)
        MotorProfile* profile = m_document->addMotor(name, color);
        
        // Undo/Redo 스택 비우기 (모터 추가/삭제는 Undo 미지원)
        m_undoStack->clear(); 
    }
}
void MainWindow::onRemoveMotor() {
    // ... (모터 찾기, 확인창)
    if (reply == QMessageBox::Yes) {
        m_document->removeMotor(profile);
        m_undoStack->clear(); // Undo/Redo 스택 비우기
    }
}
void MainWindow::onSaveDocument() { ... } // (이전과 동일)
void MainWindow::onLoadDocument() {
    // ... (파일 열기)
    if (m_document->loadFromFile(fileName)) {
        m_undoStack->clear(); // 불러오기 후 스택 비우기
    } else {
        // ... (경고창)
    }
}

// 3c. Fit to View 슬롯
void MainWindow::onFitToView() {
    m_view->fitToView();
}

// 6. 제약조건 적용
void MainWindow::onApplyConstraints() {
    MotorProfile* profile = m_document->activeProfile();
    if (profile) {
        // 이 작업은 Undo/Redo가 안되도록 함 (또는 복잡한 커맨드 생성 필요)
        profile->checkAllNodes();
    }
}
void MainWindow::onDocumentModelChanged() {
    // ... (트리 위젯 갱신)
    m_undoStack->clear(); // 모델이 통째로 바뀌면 스택 비우기
}
void MainWindow::onActiveMotorSwitched(...) {
    // ... (스핀박스 연결)
    m_undoStack->clear(); // 모터가 바뀌면 스택 비우기
}
void MainWindow::connectProfileToSpinBoxes(...) { ... } // (static_cast 사용, 이전과 동일)
void MainWindow::disconnectProfileFromSpinBoxes(...) { ... } // (static_cast 사용, 이전과 동일)


// --- 2. Export 다이얼로그 로직 ---
void MainWindow::onExportDocument() {
    if (!m_document || !m_document->activeProfile()) {
        QMessageBox::warning(this, "내보내기 오류", "선택된 모터가 없습니다.");
        return;
    }

    // 1. 다이얼로그 생성
    QDialog dialog(this);
    dialog.setWindowTitle("프로파일 내보내기");
    QVBoxLayout layout(&dialog);
    
    QRadioButton* nodesOnlyRadio = new QRadioButton("노드만 내보내기 (JSON과 유사)");
    QRadioButton* sampledRadio = new QRadioButton("샘플링하여 내보내기 (CSV)");
    nodesOnlyRadio->setChecked(true);
    layout.addWidget(nodesOnlyRadio);
    layout.addWidget(sampledRadio);

    // 샘플링 옵션용 위젯 (평소엔 숨김)
    QWidget* optionsWidget = new QWidget;
    QFormLayout* optionsLayout = new QFormLayout(optionsWidget);
    QDoubleSpinBox* endTimeSpin = new QDoubleSpinBox;
    endTimeSpin->setRange(0.1, 10000.0);
    endTimeSpin->setValue(2.0);
    endTimeSpin->setSuffix(" s");
    QSpinBox* hzSpin = new QSpinBox;
    hzSpin->setRange(1, 10000);
    hzSpin->setValue(100);
    hzSpin->setSuffix(" Hz");
    optionsLayout->addRow("종료 시간:", endTimeSpin);
    optionsLayout->addRow("샘플링 속도:", hzSpin);
    optionsWidget->setVisible(false);
    layout.addWidget(optionsWidget);

    connect(sampledRadio, &QRadioButton::toggled, optionsWidget, &QWidget::setVisible);

    QDialogButtonBox* buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
    layout.addWidget(buttonBox);
    connect(buttonBox, &QDialogButtonBox::accepted, &dialog, &QDialog::accept);
    connect(buttonBox, &QDialogButtonBox::rejected, &dialog, &QDialog::reject);

    // 2. 다이얼로그 실행
    if (dialog.exec() != QDialog::Accepted) {
        return;
    }

    // 3. 파일 경로 묻기
    QString fileName = QFileDialog::getSaveFileName(this, "내보내기", "", "CSV 파일 (*.csv)");
    if (fileName.isEmpty()) return;

    QFile file(fileName);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        QMessageBox::warning(this, "파일 오류", "파일을 열 수 없습니다.");
        return;
    }
    
    QTextStream stream(&file);

    // 4. 선택된 옵션에 따라 내보내기
    if (nodesOnlyRadio->isChecked()) {
        m_document->exportNodesToStream(stream);
    } else {
        m_document->exportSamplesToStream(stream, hzSpin->value(), endTimeSpin->value());
    }

    file.close();
    statusBar()->showMessage("내보내기 완료.", 2000);
}

